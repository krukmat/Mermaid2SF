<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Flow Visualizer</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" />
  <style>
    :root {
      --bg: #0b1021;
      --panel: #131a33;
      --accent: #66e0ff;
      --text: #e8ecff;
      --muted: #9aa5d3;
      --surface: #1c2547;
      --pill: #223054;
    }
    [data-theme='light'] {
      --bg: #f5f7ff;
      --panel: #ffffff;
      --accent: #2b7fff;
      --text: #0b1530;
      --muted: #5c6a8a;
      --surface: #f0f3ff;
      --pill: #dfe6f7;
    }
    .status-stack { position: fixed; top: 78px; right: 1rem; display: flex; flex-direction: column; gap: 0.5rem; z-index: 15; width: min(320px, 90vw); }
    .status-banner { border-radius: 10px; padding: 0.85rem 1rem; border: 1px solid #22305455; background: #182047ee; color: var(--text); box-shadow: 0 20px 40px rgba(5, 6, 18, 0.35); display: flex; justify-content: space-between; gap: 0.75rem; align-items: flex-start; }
    .status-banner strong { display: block; font-size: 0.95rem; margin-bottom: 0.15rem; }
    .status-banner p { margin: 0; color: var(--muted); font-size: 0.85rem; }
    .status-banner button { background: transparent; border: none; color: inherit; cursor: pointer; font-size: 1rem; padding: 0; min-width: 24px; }
    .status-banner.success { border-color: #37e29d55; background: #133228ee; }
    .status-banner.info { border-color: #3a8dff55; background: #122649ee; }
    .status-banner.warning { border-color: #f5a52455; background: #332710ee; }
    .status-banner.error { border-color: #ff6b6b55; background: #401a26ee; }
    .inline-status { font-size: 0.9rem; margin: 0.35rem 0 0; color: var(--muted); padding-left: 0.2rem; }
    .inline-status.success { color: #37e29d; }
    .inline-status.info { color: #66e0ff; }
    .inline-status.warning { color: #f5a524; }
    .inline-status.error { color: #ff6b6b; }
    body { font-family: 'Inter', system-ui, sans-serif; margin: 0; background: var(--bg); color: var(--text); transition: background 180ms ease, color 180ms ease; }
    header { padding: 1rem 1.5rem; background: var(--panel); display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #22305422; position: sticky; top: 0; z-index: 5; flex-wrap: wrap; gap: 0.5rem; }
    main { display: grid; grid-template-columns: 340px 1fr; min-height: 100vh; }
    .hero { background: radial-gradient(circle at 20% 20%, rgba(102,224,255,0.08), transparent 35%), radial-gradient(circle at 80% 0%, rgba(111,90,255,0.12), transparent 40%), linear-gradient(135deg, var(--panel), var(--bg)); color: var(--text); padding: 3rem 1.5rem 2.5rem; border-bottom: 1px solid #22305422; }
    .hero-grid { display: grid; grid-template-columns: 1fr 420px; gap: 2rem; align-items: center; }
    .hero-badge { display: inline-flex; align-items: center; gap: 0.4rem; padding: 0.4rem 0.7rem; border-radius: 999px; background: rgba(102,224,255,0.1); border: 1px solid rgba(102,224,255,0.25); color: var(--accent); font-weight: 700; }
    .hero-cta { display: flex; gap: 0.75rem; flex-wrap: wrap; margin-top: 1rem; }
    .hero-note { margin-top: 1rem; border-radius: 10px; border: 1px solid rgba(102,224,255,0.35); padding: 0.8rem 1rem; background: rgba(7,10,24,0.85); font-size: 0.95rem; line-height: 1.5; }
    .hero-card { background: var(--surface); border: 1px solid #22305422; border-radius: 14px; padding: 1rem; position: relative; overflow: hidden; min-height: 260px; }
    .pulse { position: absolute; width: 140px; height: 140px; border-radius: 999px; background: rgba(102,224,255,0.1); filter: blur(12px); animation: float 6s ease-in-out infinite; }
    .pulse:nth-child(1) { top: -20px; left: -10px; animation-delay: 0.2s; }
    .pulse:nth-child(2) { bottom: -20px; right: -20px; animation-delay: 1.4s; }
    .pulse:nth-child(3) { top: 40%; left: 40%; animation-delay: 2.1s; }
    .hero-diagram { position: relative; z-index: 1; display: grid; gap: 0.6rem; }
    .chip { display: inline-flex; align-items: center; gap: 0.4rem; padding: 0.35rem 0.7rem; border-radius: 10px; background: rgba(102,224,255,0.08); border: 1px solid rgba(102,224,255,0.2); font-size: 0.9rem; }
    .sidebar { background: var(--panel); padding: 1.5rem; border-right: 1px solid #22305422; overflow-y: auto; }
    .content { padding: 1.5rem; }
    .card { background: var(--surface); border: 1px solid #22305422; border-radius: 10px; padding: 1rem; margin-bottom: 1rem; }
    .tip-card { background: rgba(102,224,255,0.06); border-color: rgba(102,224,255,0.45); }
    .tip-card small { display: block; margin-top: 0.25rem; color: var(--muted); font-size: 0.8rem; }
    label { display: block; margin-bottom: 0.25rem; color: var(--muted); font-size: 0.9rem; }
    input, textarea { width: 100%; padding: 0.6rem 0.7rem; border-radius: 8px; border: 1px solid #22305422; background: #0f153133; color: var(--text); }
    textarea { min-height: 120px; }
    button { background: var(--accent); color: #04132e; border: none; border-radius: 8px; padding: 0.7rem 1rem; font-weight: 700; cursor: pointer; }
    button:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
    button.secondary { background: transparent; color: var(--accent); border: 1px solid var(--accent); }
    button[aria-busy='true'] { position: relative; opacity: 0.7; pointer-events: none; }
    button[aria-busy='true']::after { content: ''; position: absolute; right: 0.75rem; top: 50%; width: 14px; height: 14px; border: 2px solid currentColor; border-right-color: transparent; border-radius: 50%; transform: translateY(-50%); animation: spin 0.65s linear infinite; }
    .row { display: flex; gap: 0.5rem; align-items: center; }
    .row button { flex: 1; }
    .canvas { background: #0f153133; border: 1px dashed #22305455; border-radius: 10px; padding: 1rem; min-height: 520px; overflow: hidden; position: relative; }
    .canvas-inner { position: relative; width: 100%; height: 100%; min-height: 520px; transform-origin: top left; transition: transform 120ms ease-out; }
    svg.edges { position: absolute; inset: 0; pointer-events: none; overflow: visible; }
    .edge-label { fill: #9aa5d3; font-size: 12px; pointer-events: none; }
    .edge-line { stroke: #66e0ff99; stroke-width: 2; transition: stroke 120ms ease; }
    .edge-line.highlight { stroke: #ffd166; stroke-width: 3; }
    .node { position: absolute; padding: 0.4rem 0.75rem; border-radius: 8px; display: inline-flex; gap: 0.4rem; align-items: center; cursor: grab; user-select: none; }
    .node .node-tooltip { position: absolute; top: 100%; left: 50%; transform: translate(-50%, 8px); background: var(--panel); border: 1px solid #22305422; border-radius: 6px; padding: 0.35rem 0.5rem; font-size: 0.75rem; color: var(--text); opacity: 0; pointer-events: none; transition: opacity 0.15s ease, transform 0.15s ease; white-space: nowrap; z-index: 10; box-shadow: 0 6px 14px rgba(0,0,0,0.25); }
    .node:hover .node-tooltip { opacity: 1; transform: translate(-50%, 12px); }
    .modal-field { margin-bottom: 0.75rem; }
    .field-helper { display: block; font-size: 0.75rem; color: var(--muted); margin-top: 0.25rem; }
    .field-error { display: none; font-size: 0.7rem; color: #ff6b6b; margin-top: 0.25rem; }
    .context-help { font-size: 0.85rem; color: #66e0ff; margin-bottom: 0.4rem; }
    .node.start { background: #14d88e33; border: 1px solid #14d88e; }
    .node.end { background: #ff758c33; border: 1px solid #ff758c; }
    .node.decision { background: #f5a52433; border: 1px solid #f5a524; }
    .node.default { background: #66e0ff33; border: 1px solid #66e0ff; }
    .edge { color: var(--muted); font-size: 0.85rem; }
    .list { list-style: none; padding: 0; margin: 0; }
    .list li { background: #0f153133; border: 1px solid #22305455; border-radius: 8px; padding: 0.6rem; margin-bottom: 0.4rem; display: flex; justify-content: space-between; align-items: center; cursor: grab; }
    .list li.dragging { opacity: 0.6; }
    .pill { padding: 0.2rem 0.5rem; border-radius: 8px; background: var(--pill); color: var(--muted); font-size: 0.8rem; display: inline-flex; align-items: center; gap: 0.35rem; }
    .template-grid { display: grid; gap: 0.5rem; }
    .template-card { border: 1px dashed #22305444; border-radius: 10px; padding: 0.6rem 0.75rem; background: #0f153122; }
    .template-card header { display: flex; justify-content: space-between; align-items: center; padding: 0; background: transparent; border: none; }
    .template-card small { color: var(--muted); }
    .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.45); display: flex; align-items: center; justify-content: center; z-index: 20; }
    .modal { background: var(--panel); border: 1px solid #22305455; border-radius: 12px; width: min(560px, 90vw); max-height: 80vh; overflow: auto; padding: 1rem 1.25rem; box-shadow: 0 20px 60px rgba(0,0,0,0.35); }
    .modal header { display: flex; justify-content: space-between; align-items: center; padding: 0; border: none; }
    .modal .row { flex-wrap: wrap; }
    .flow-tabs-wrapper { display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.5rem; }
    .flow-tabs { display: flex; gap: 0.35rem; flex-wrap: wrap; }
    .flow-tab { border: 1px solid rgba(255, 255, 255, 0.25); background: rgba(255, 255, 255, 0.05); color: var(--text); border-radius: 8px; padding: 0.35rem 0.65rem; cursor: pointer; font-size: 0.85rem; display: inline-flex; align-items: center; gap: 0.35rem; }
    .flow-tab.active { border-color: #66e0ff; background: rgba(102, 224, 255, 0.15); }
    .flow-tab .flow-indicator { width: 6px; height: 6px; border-radius: 50%; background: #66e0ff; margin-left: 0.2rem; }
    .canvas-empty { position: absolute; inset: 40px; border-radius: 10px; border: 2px dashed rgba(255, 255, 255, 0.3); background: rgba(2, 7, 25, 0.8); display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; gap: 0.5rem; padding: 1.2rem; backdrop-filter: blur(2px); }
    .canvas-empty h4 { margin: 0; font-size: 1.1rem; }
    .canvas-empty button { border: 1px solid rgba(102, 224, 255, 0.4); background: transparent; color: var(--text); border-radius: 8px; padding: 0.45rem 0.9rem; cursor: pointer; }
    .status-details-card { position: relative; }
    .status-details-card[data-level='error'] { border-color: #ff6b6b; }
    .status-details-card[data-level='warning'] { border-color: #f5a524; }
    .status-details-card[data-level='success'] { border-color: #37e29d; }
    .status-details-card[data-level='info'] { border-color: #3a8dff; }
    .status-list { list-style: none; padding-left: 0; margin: 0.5rem 0 0; }
    .status-list li { font-size: 0.85rem; padding: 0.35rem 0; border-bottom: 1px solid rgba(255, 255, 255, 0.05); }
    .advanced-card .row { flex-wrap: wrap; gap: 0.5rem; }
    .advanced-card button { font-size: 0.8rem; padding: 0.45rem 0.75rem; border-radius: 999px; border: 1px solid rgba(255, 255, 255, 0.2); background: rgba(255, 255, 255, 0.05); color: var(--text); cursor: pointer; }
    .advanced-card button.active { border-color: #66e0ff; background: rgba(102, 224, 255, 0.1); }
    .node.advanced-highlight { box-shadow: 0 0 0 2px rgba(255, 209, 102, 0.85); }
    .loading-backdrop { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.65); display: flex; align-items: center; justify-content: center; z-index: 30; gap: 0.75rem; color: #fff; font-size: 0.9rem; flex-direction: column; }
    .loading-backdrop.hidden { display: none; }
    .loading-spinner { width: 48px; height: 48px; border: 4px solid rgba(255, 255, 255, 0.2); border-top-color: #66e0ff; border-radius: 50%; animation: spin 0.9s linear infinite; }
    .tutorial-overlay { position: fixed; inset: 0; background: rgba(1, 6, 18, 0.6); z-index: 40; display: flex; align-items: center; justify-content: center; flex-direction: column; gap: 1rem; padding: 1rem; }
    .tutorial-overlay.hidden { display: none; }
    .tutorial-card { background: var(--panel); border: 1px solid #22305455; border-radius: 16px; padding: 1.25rem; max-width: 420px; text-align: center; }
    .tutorial-progress { font-size: 0.85rem; color: var(--muted); text-transform: uppercase; letter-spacing: 0.15rem; }
    .tutorial-actions { display: flex; justify-content: space-between; gap: 0.5rem; margin-top: 1rem; }
    .tutorial-highlight { position: absolute; border: 2px solid #66e0ff; border-radius: 12px; pointer-events: none; box-shadow: 0 8px 24px rgba(102, 224, 255, 0.35); transition: transform 0.15s ease; }
    .import-modal { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.75); z-index: 45; }
    .import-modal.hidden { display: none; }
    .import-panel { background: var(--panel); border: 1px solid #22305455; border-radius: 16px; padding: 1.25rem; width: min(560px, 90vw); max-height: 90vh; overflow: auto; color: var(--text); }
    .import-panel header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; }
    .import-dropzone { border: 2px dashed rgba(102, 224, 255, 0.4); border-radius: 12px; padding: 1rem; text-align: center; cursor: pointer; transition: border 0.2s ease; }
    .import-dropzone.hover { border-color: rgba(255, 255, 255, 0.9); }
    .import-panel textarea { width: 100%; min-height: 120px; background: #0b1226; border-radius: 10px; border: 1px solid #22305455; color: var(--text); padding: 0.75rem; }
    .import-export-row { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.5rem; }
    .import-status { margin-top: 0.5rem; font-size: 0.85rem; color: var(--muted); }
    .import-status.success { color: #37e29d; }
    .import-status.warning { color: #f5a524; }
    .import-status.error { color: #ff6b6b; }
    .history-card { border: 1px solid #22305455; border-radius: 10px; padding: 1rem; background: rgba(7, 10, 24, 0.8); margin-bottom: 1rem; }
    .history-card strong { display: block; margin-bottom: 0.25rem; }
    .history-card .row { gap: 0.5rem; }
    .history-modal { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.65); z-index: 50; }
    .history-modal.hidden { display: none; }
    .history-panel { background: var(--panel); border: 1px solid #22305455; border-radius: 16px; padding: 1.25rem; width: min(620px, 90vw); max-height: 90vh; overflow: auto; }
    .history-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 0.75rem; }
    .history-entry { display: flex; justify-content: space-between; align-items: center; padding: 0.65rem; border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.1); background: rgba(255, 255, 255, 0.02); }
    .history-entry small { color: var(--muted); display: block; margin-top: 0.1rem; }
    .history-actions { display: flex; gap: 0.35rem; }
    .history-actions button { padding: 0.3rem 0.65rem; font-size: 0.78rem; }
    .history-status { margin-top: 0.5rem; font-size: 0.85rem; color: var(--muted); }
    @keyframes float { 0% { transform: translateY(0); opacity: 0.9; } 50% { transform: translateY(-10px); opacity: 1; } 100% { transform: translateY(0); opacity: 0.9; } }
    @keyframes spin { 0% { transform: translateY(-50%) rotate(0deg); } 100% { transform: translateY(-50%) rotate(360deg); } }
    @media (max-width: 1100px) {
      main { grid-template-columns: 1fr; }
      .hero-grid { grid-template-columns: 1fr; }
      .sidebar { order: 2; }
      .content { order: 1; }
    }
    @media (max-width: 768px) {
      .row { flex-wrap: wrap; }
      .hero { padding: 2.5rem 1rem 2rem; }
      header { padding: 0.75rem 1rem; }
      .status-stack { position: fixed; bottom: 0.75rem; top: auto; right: 0.75rem; left: 0.75rem; width: auto; }
    }
  </style>
</head>
<body>
  <header>
    <h2>Flow Visualizer</h2>
    <div class="row" style="gap:0.75rem;">
      <button id="themeToggle" class="secondary" style="min-width:120px;" aria-pressed="false" aria-label="Toggle theme">Toggle Theme</button>
      <button id="ping">Check Backend</button>
      <button class="secondary" id="reset">Reset</button>
      <button id="startTutorial" class="secondary" style="min-width:140px;" aria-label="Start onboarding tutorial">Start Tutorial</button>
    </div>
  </header>
  <div id="statusStack" class="status-stack" aria-live="polite" aria-atomic="true"></div>
  <section class="hero">
    <div class="hero-grid">
      <div>
        <div class="hero-badge">Flows as Code ¬∑ Git/CI Ready</div>
        <h1 style="margin:0.6rem 0 0.4rem;">Build Salesforce Flows Visually, Ship from Git</h1>
        <p style="color: var(--muted); max-width: 640px;">
          Drag, drop, compile. From Mermaid diagrams to deployable Flow XML with live previews, examples, and a ready-to-use CI pipeline.
        </p>
        <div class="hero-cta">
          <button onclick="scrollToBuilder()">Start Building</button>
          <button class="secondary" onclick="loadTemplate('onboarding')">Use Onboarding Template</button>
          <button class="secondary" onclick="window.open('http://iotforce.es/flow/', '_blank')">Try Live Demo</button>
        </div>
        <div class="hero-note">
          Build in the browser and ship via CLI. Every compile shown here is backed by the same Mermaid ‚Üí DSL ‚Üí Flow XML pipeline that runs in CI, so you always know the metadata that will deploy.
        </div>
        <div style="margin-top:0.75rem; display:flex; gap:0.5rem; flex-wrap: wrap;">
          <span class="chip">Mermaid ‚Üí XML/DSL/Docs</span>
          <span class="chip">Live XML Preview</span>
          <span class="chip">CI-ready (lint/test/build)</span>
        </div>
      </div>
      <div class="hero-card">
        <div class="pulse"></div><div class="pulse"></div><div class="pulse"></div>
        <div class="hero-diagram">
          <div class="node start" style="position:relative;">‚ñ∂ Start</div>
          <div class="edge">‚Üí Screen: Collect Info</div>
          <div class="node default" style="position:relative;">üìã Screen</div>
          <div class="edge">‚Üí Decision: Route</div>
          <div class="node decision" style="position:relative;">üîÄ Decision</div>
          <div class="edge">Yes ‚Üí Assignment / No ‚Üí End</div>
          <div class="node default" style="position:relative;">‚úèÔ∏è Assignment</div>
          <div class="node end" style="position:relative;">‚èπ End</div>
        </div>
      </div>
    </div>
  </section>
  <main>
    <section class="sidebar">
      <div class="card">
        <strong>Toolbox</strong>
        <div class="row" style="margin-top:0.5rem; flex-wrap: wrap;">
          <button data-add="Start">+ Start</button>
          <button data-add="Screen">+ Screen</button>
          <button data-add="Assignment">+ Assignment</button>
          <button data-add="Decision">+ Decision</button>
          <button data-add="GetRecords">+ GetRecords</button>
          <button data-add="Loop">+ Loop</button>
          <button data-add="Wait">+ Wait</button>
          <button data-add="Fault">+ Fault</button>
          <button data-add="End">+ End</button>
        </div>
      </div>
      <div class="card">
        <strong>Templates</strong>
        <div class="template-grid" id="templateGrid" style="margin-top:0.5rem;"></div>
      </div>
      <div class="card tip-card">
        <strong>Advanced nodes guide</strong>
        <small>Loop = retries (condition &amp; iterations), Wait = delays/signal gating, Fault = capture errors with metadata.</small>
        <small>Use the status banner to monitor compile/validation events that involve these nodes.</small>
      </div>
      <div class="card advanced-card">
        <strong>Advanced nodes cues</strong>
        <p id="advancedHelper" class="inline-status info" role="status" aria-live="polite">
          Click a pill to highlight Loop, Wait, or Fault nodes in the canvas.
        </p>
        <div class="row">
          <button type="button" data-advanced-target="Loop">Loop</button>
          <button type="button" data-advanced-target="Wait">Wait</button>
          <button type="button" data-advanced-target="Fault">Fault</button>
          <button type="button" data-advanced-target="clear">Clear</button>
        </div>
      </div>
      <div class="flow-tabs-wrapper">
        <div class="flow-tabs" id="flowTabs"></div>
        <button id="newFlow" class="secondary" type="button">+ New Flow</button>
      </div>
      <div class="card">
        <strong>Nodes (drag to reorder)</strong>
        <ul id="nodeList" class="list"></ul>
      </div>
      <div class="card" id="editorCard" style="display:none;">
        <strong>Edit Node</strong>
        <div style="margin-top:0.5rem;" id="form"></div>
      </div>
      <div class="card">
        <strong>Export</strong>
        <div class="row" style="margin-top:0.5rem;">
          <button id="exportMermaid">Mermaid</button>
          <button class="secondary" id="exportDsl">DSL JSON</button>
          <button class="secondary" id="openImportExport">Import/Export</button>
        </div>
      </div>
      <div class="card">
        <strong>Status</strong>
        <pre id="output" style="white-space:pre-wrap; background:#0f1531; padding:0.75rem; border-radius:8px; border:1px solid #223054;">Ready.</pre>
      </div>
    </section>
    <section class="content" id="builder">
      <div class="card">
        <h3 style="margin-top:0;">Canvas</h3>
        <div class="row" style="gap:0.5rem; margin-bottom:0.5rem; flex-wrap: wrap;">
          <span class="pill">View</span>
          <button class="secondary" id="zoomOut" style="min-width:72px;">-</button>
          <button class="secondary" id="zoomIn" style="min-width:72px;">+</button>
          <button id="resetView" style="min-width:120px;">Reset</button>
        </div>
        <div class="canvas" id="canvas">
          <div class="canvas-inner" id="canvasInner"></div>
          <div id="emptyOverlay" class="canvas-empty hidden" role="status" aria-live="polite">
            <h4>Start your first flow</h4>
            <p>Drag a Start node or load the onboarding template to see the canvas light up.</p>
            <div class="row" style="gap:0.5rem; margin-top:0.5rem;">
              <button id="emptyStartTutorial" type="button">Start tutorial</button>
              <button id="emptyLoadTemplate" type="button">Load template</button>
            </div>
          </div>
        </div>
      </div>
      <div class="card">
        <h3 style="margin-top:0;">Mermaid Preview</h3>
        <pre id="mermaidPreview" style="background:#0f1531; padding:1rem; border-radius:8px; border:1px solid #223054; white-space:pre-wrap;"></pre>
        <div id="previewHint" class="inline-status info" role="status" aria-live="polite">
          Tip: Drag templates or add Start/Screen nodes to kick off the flow. Loop/Wait/Fault nodes surface their metadata in the Mermaid output.
        </div>
      </div>
      <div class="card">
        <h3 style="margin-top:0;">XML Preview</h3>
        <div class="row" style="margin-bottom:0.5rem;">
          <button id="compileXml">Compile &amp; Preview XML</button>
          <button class="secondary" id="downloadXml">Download XML</button>
        </div>
        <div id="xmlStatus" class="inline-status info" role="status" aria-live="polite">Not compiled yet.</div>
        <pre id="xmlPreview" class="language-xml" style="background:#0f1531; padding:1rem; border-radius:8px; border:1px solid #223054; white-space:pre-wrap; max-height:260px; overflow:auto;">Not compiled yet.</pre>
      </div>
      <div class="card status-details-card" id="statusDetails" data-level="info">
        <strong>Status &amp; Issues</strong>
        <p id="statusDetailsSummary" class="inline-status info">No active issues.</p>
        <ul id="statusDetailsList" class="status-list"></ul>
      </div>
      <div class="card history-card">
        <strong>Version history</strong>
        <p id="historySummary" class="inline-status info">No snapshots yet.</p>
        <div class="row">
          <button id="captureHistory" type="button">Save snapshot</button>
          <button id="openHistory" type="button" class="secondary">Open history</button>
        </div>
      </div>
      <div class="card">
        <strong>Keyboard shortcuts</strong>
        <p id="shortcutsSummary" class="inline-status info">Quick combos keep you in flow. Toggle them off if needed.</p>
        <ul class="list" id="shortcutSummaryList" aria-live="polite"></ul>
        <div class="row" style="margin-top:0.5rem;">
          <button id="toggleShortcuts" type="button">Shortcuts: On</button>
          <button id="showShortcutsGuide" type="button" class="secondary">Show guide</button>
        </div>
      </div>
    </section>
  </main>
  <div id="loadingBackdrop" class="loading-backdrop hidden" aria-live="polite">
    <div class="loading-spinner" aria-hidden="true"></div>
    <p id="loadingMessage">Loading...</p>
  </div>
  <div id="tutorialOverlay" class="tutorial-overlay hidden" aria-hidden="true">
    <div class="tutorial-card" role="dialog" aria-modal="true">
      <p class="tutorial-progress"><span id="tutorialProgress">1/5</span></p>
      <h3 id="tutorialTitle">Welcome</h3>
      <p id="tutorialDescription">Discover how to build and compile flows from the canvas.</p>
      <div class="tutorial-actions">
        <button id="tutorialPrev" type="button" class="secondary">Previous</button>
        <button id="tutorialNext" type="button">Next</button>
      </div>
      <button id="tutorialSkip" type="button" class="secondary" style="margin-top:0.5rem;">Skip tutorial</button>
    </div>
      <div id="tutorialHighlight" class="tutorial-highlight"></div>
    </div>

  <div id="importExportModal" class="import-modal hidden" aria-hidden="true">
    <div class="import-panel" role="dialog" aria-modal="true">
      <header>
        <h3>Import / Export hub</h3>
        <button id="closeImportExport" class="secondary" type="button" aria-label="Close import export modal">Close</button>
      </header>
      <section>
        <strong>Import</strong>
        <p class="import-status" id="importStatus">Drop a Mermaid (.mmd), DSL (.json/.dsl), or Flow XML (.flow-meta.xml) file.</p>
        <div id="importDropzone" class="import-dropzone" role="button" tabindex="0">
          Drop file here or click to browse
          <input id="importFile" type="file" accept=".mmd,.json,.dsl,.xml,.flow-meta.xml" style="display:none;" />
        </div>
        <textarea id="importTextarea" placeholder="Paste Mermaid, DSL JSON, or Flow XML and click Load"></textarea>
        <div class="import-export-row">
          <button id="loadMermaidFromText" type="button">Load Mermaid text</button>
          <button id="loadDslFromText" type="button">Load DSL JSON</button>
          <button id="loadXmlFromText" type="button">Load Flow XML</button>
        </div>
      </section>
      <section style="margin-top:1rem;">
        <strong>Export</strong>
        <div class="import-export-row">
          <button id="downloadMermaid" type="button">Download Mermaid</button>
          <button id="downloadDsl" type="button">Download DSL</button>
          <button id="exportDownloadXml" type="button">Download Flow XML</button>
          <button id="downloadSvg" type="button">Download SVG snapshot</button>
          <button id="downloadPng" type="button">Download PNG snapshot</button>
        </div>
      </section>
    </div>
  </div>
  <div id="historyModal" class="history-modal hidden" aria-hidden="true">
    <div class="history-panel" role="dialog" aria-modal="true">
      <header style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.75rem;">
        <strong>Flow history</strong>
        <button id="closeHistory" class="secondary" type="button" aria-label="Close history modal">Close</button>
      </header>
      <p id="historyStatus" class="history-status">Snapshots capture nodes, pan, scale, and serialized DSL/XML.</p>
      <ul id="historyList" class="history-list"></ul>
    </div>
  </div>
  <div id="shortcutsModal" class="history-modal hidden" aria-hidden="true">
    <div class="history-panel" role="dialog" aria-modal="true">
      <header style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.75rem;">
        <strong>Shortcut guide</strong>
        <button id="closeShortcutsPanel" class="secondary" type="button" aria-label="Close shortcut guide">Close</button>
      </header>
      <p id="shortcutsStatus" class="history-status">Shortcuts accelerate compile, history, and templates.</p>
      <ul id="shortcutList" class="history-list"></ul>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <script>
    const API_BASE = (window.location && window.location.origin) || 'http://localhost:4000';

    const output = document.getElementById('output');
    const canvas = document.getElementById('canvas');
    const canvasInner = document.getElementById('canvasInner');
    const list = document.getElementById('nodeList');
    const form = document.getElementById('form');
    const editorCard = document.getElementById('editorCard');
    const mermaidPreview = document.getElementById('mermaidPreview');
    const previewHintEl = document.getElementById('previewHint');
    const templateGrid = document.getElementById('templateGrid');
    const compileButton = document.getElementById('compileXml');
    const downloadButton = document.getElementById('downloadXml');
    const importExportModal = document.getElementById('importExportModal');
    const importDropzone = document.getElementById('importDropzone');
    const importFileInput = document.getElementById('importFile');
    const importTextarea = document.getElementById('importTextarea');
    const importStatusEl = document.getElementById('importStatus');
    const loadMermaidFromText = document.getElementById('loadMermaidFromText');
    const loadDslFromText = document.getElementById('loadDslFromText');
    const loadXmlFromText = document.getElementById('loadXmlFromText');
    const openImportExportBtn = document.getElementById('openImportExport');
    const closeImportExportBtn = document.getElementById('closeImportExport');
    const downloadMermaidHub = document.getElementById('downloadMermaid');
    const downloadDslHub = document.getElementById('downloadDsl');
    const downloadXmlHub = document.getElementById('exportDownloadXml');
    const downloadSvgHub = document.getElementById('downloadSvg');
    const downloadPngHub = document.getElementById('downloadPng');
    const pingButton = document.getElementById('ping');
    const statusStack = document.getElementById('statusStack');
    const xmlStatus = document.getElementById('xmlStatus');
    const historySummaryEl = document.getElementById('historySummary');
    const historyModal = document.getElementById('historyModal');
    const historyList = document.getElementById('historyList');
    const historyStatusEl = document.getElementById('historyStatus');
    const openHistoryBtn = document.getElementById('openHistory');
    const historyCloseBtn = document.getElementById('closeHistory');
    const captureHistoryBtn = document.getElementById('captureHistory');
    const shortcutsSummaryEl = document.getElementById('shortcutsSummary');
    const shortcutSummaryList = document.getElementById('shortcutSummaryList');
    const toggleShortcutsBtn = document.getElementById('toggleShortcuts');
    const showShortcutsGuideBtn = document.getElementById('showShortcutsGuide');
    const shortcutsModal = document.getElementById('shortcutsModal');
    const shortcutList = document.getElementById('shortcutList');
    const closeShortcutsPanelBtn = document.getElementById('closeShortcutsPanel');
    const shortcutsStatusEl = document.getElementById('shortcutsStatus');
    const emptyOverlay = document.getElementById('emptyOverlay');
    const emptyStartTutorialBtn = document.getElementById('emptyStartTutorial');
    const emptyLoadTemplateBtn = document.getElementById('emptyLoadTemplate');
    const loadingBackdrop = document.getElementById('loadingBackdrop');
    const loadingMessage = document.getElementById('loadingMessage');
    const statusDetails = document.getElementById('statusDetails');
    const statusDetailsList = document.getElementById('statusDetailsList');
    const statusDetailsSummary = document.getElementById('statusDetailsSummary');
    const advancedHelper = document.getElementById('advancedHelper');
    const advancedButtons = document.querySelectorAll('[data-advanced-target]');
    const tutorialTrigger = document.getElementById('startTutorial');
    const tutorialOverlay = document.getElementById('tutorialOverlay');
    const tutorialHighlight = document.getElementById('tutorialHighlight');
    const tutorialTitle = document.getElementById('tutorialTitle');
    const tutorialDescription = document.getElementById('tutorialDescription');
    const tutorialProgress = document.getElementById('tutorialProgress');
    const tutorialPrev = document.getElementById('tutorialPrev');
    const tutorialNext = document.getElementById('tutorialNext');
    const tutorialSkip = document.getElementById('tutorialSkip');
    const flowTabs = document.getElementById('flowTabs');
    const newFlowBtn = document.getElementById('newFlow');
    let modalEl = null;

    let nodes = [];
    let selectedId = null;
    let scale = 1;
    let panX = 0;
    let panY = 0;
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    let draggingNode = null;
    let dragOffset = { x: 0, y: 0 };
    let bannerCounter = 0;
    let renderPending = false;
    let edgeSvg = null;
    let hoverHighlightId = null;
    let latestXml = '';
    let latestMermaid = '';
    let latestDslData = null;
    const flowBuffers = new Map();
    let activeFlowId = null;
    let flowCounter = 1;
    let activeAdvancedType = null;
    let tutorialActive = false;
    let tutorialStep = 0;
   const tutorialSteps = [
      {
        title: 'Welcome aboard',
        description: 'Flow Visualizer turns Mermaid diagrams into deployable Flow XML. The canvas, preview, and status cards all stay in sync.',
        selector: '.hero',
      },
      {
        title: 'Add your first node',
        description: 'Use the Start button in the toolbox to drop the initial node, then drag it on the grid to position it.',
        selector: '[data-add="Start"]',
      },
      {
        title: 'Advanced nodes',
        description: 'Loop, Wait, and Fault nodes appear in the sidebar tip card. Highlight them to understand how they behave.',
        selector: '.tip-card',
      },
      {
        title: 'Compile & preview',
        description: 'Hit Compile & Preview XML to send the diagram to the backend and watch the status banners update.',
        selector: '#compileXml',
      },
      {
        title: 'Monitor issues',
        description: 'The Status & Issues card lists compile errors and warnings; use it to fix problems before downloading.',
        selector: '#statusDetails',
      },
    ];
    const SHORTCUTS_STORAGE_KEY = 'flow-shortcuts-enabled';
    const shortcutDefinitions = [
      { combo: 'Ctrl/Cmd+S', description: 'Compile the active flow' },
      { combo: 'Ctrl/Cmd+T', description: 'Start the onboarding tutorial' },
      { combo: 'Ctrl/Cmd+L', description: 'Load the onboarding template' },
      { combo: 'Ctrl/Cmd+P', description: 'Refresh the Mermaid preview' },
      { combo: 'Ctrl/Cmd+Z', description: 'Restore the latest snapshot' },
      { combo: 'Ctrl/Cmd+Y', description: 'Open the history modal' },
      { combo: 'Delete', description: 'Remove the selected node' },
      { combo: 'Arrow keys', description: 'Nudge the selected node by 10px' },
    ];
    let shortcutsEnabled = true;
    const storedShortcuts = localStorage.getItem(SHORTCUTS_STORAGE_KEY);
    if (storedShortcuts !== null) {
      shortcutsEnabled = storedShortcuts === 'true';
    }
    const SHORTCUT_NUDGE_STEP = 10;

    function showBanner({ type = 'info', title = '', message = '', duration = 7000, sticky = false } = {}) {
      if (!statusStack) return;
      const banner = document.createElement('div');
      banner.className = `status-banner ${type}`;
      banner.dataset.bannerId = `banner-${++bannerCounter}`;
      const textWrap = document.createElement('div');
      if (title) {
        const strong = document.createElement('strong');
        strong.textContent = title;
        textWrap.appendChild(strong);
      }
      if (message) {
        const para = document.createElement('p');
        para.textContent = message;
        textWrap.appendChild(para);
      }
      if (!title && !message) {
        const para = document.createElement('p');
        para.textContent = 'Update available.';
        textWrap.appendChild(para);
      }
      banner.appendChild(textWrap);
      const close = document.createElement('button');
      close.setAttribute('aria-label', 'Dismiss notification');
      close.innerHTML = '&times;';
      close.addEventListener('click', () => removeBanner(banner));
      banner.appendChild(close);
      banner.setAttribute('role', type === 'error' || type === 'warning' ? 'alert' : 'status');
      statusStack.appendChild(banner);
      if (!sticky) {
        setTimeout(() => removeBanner(banner), duration);
      }
      return banner.dataset.bannerId;
    }

    function removeBanner(el) {
      if (el && el.parentNode) {
        el.parentNode.removeChild(el);
      }
    }

    function setXmlStatus(message, tone = 'info') {
      if (!xmlStatus) return;
      xmlStatus.textContent = message;
      xmlStatus.className = `inline-status ${tone}`;
    }

    function setPreviewHint(message, tone = 'info') {
      if (!previewHintEl) return;
      previewHintEl.textContent = message;
      previewHintEl.className = `inline-status ${tone}`;
    }

    function setButtonLoading(button, isLoading, loadingLabel) {
      if (!button) return;
      if (isLoading) {
        if (!button.dataset.originalText) {
          button.dataset.originalText = button.textContent;
        }
        if (loadingLabel) {
          button.textContent = loadingLabel;
        }
        button.setAttribute('aria-busy', 'true');
        button.disabled = true;
      } else {
        if (button.dataset.originalText) {
          button.textContent = button.dataset.originalText;
        }
        button.removeAttribute('aria-busy');
        button.disabled = false;
      }
    }

    function setLoadingState(active, message = 'Processing...') {
      if (!loadingBackdrop) return;
      loadingBackdrop.classList.toggle('hidden', !active);
      if (message && loadingMessage) {
        loadingMessage.textContent = message;
      }
    }

    function updateImportStatus(message, tone = 'info') {
      if (!importStatusEl) return;
      importStatusEl.textContent = message;
      importStatusEl.className = `import-status ${tone}`;
    }

    function loadStoredHistory(flowId) {
      if (!flowId) return [];
      const stored = localStorage.getItem(`flow-history-${flowId}`);
      if (!stored) return [];
      try {
        return JSON.parse(stored);
      } catch {
        return [];
      }
    }

    function persistFlowHistory(flow) {
      if (!flow) return;
      localStorage.setItem(`flow-history-${flow.id}`, JSON.stringify(flow.history || []));
    }

    function getActiveFlow() {
      return flowBuffers.get(activeFlowId);
    }

    function updateHistorySummary(flow = getActiveFlow()) {
      if (!historySummaryEl) return;
      const latest = flow?.history?.[0];
      if (!latest) {
        historySummaryEl.textContent = 'No snapshots yet.';
        historySummaryEl.className = 'inline-status info';
        return;
      }
      const when = new Date(latest.timestamp).toLocaleTimeString();
      historySummaryEl.textContent = `Last snapshot: ${latest.label} at ${when} (${latest.nodesCount} nodes)`;
      historySummaryEl.className = 'inline-status success';
    }

    function renderHistoryList() {
      if (!historyList) return;
      const flow = getActiveFlow();
      historyList.innerHTML = '';
      if (!flow || !flow.history || flow.history.length === 0) {
        const li = document.createElement('li');
        li.className = 'history-entry';
        li.textContent = 'No snapshots saved yet.';
        historyList.appendChild(li);
        return;
      }
      flow.history.forEach((entry, index) => {
        const li = document.createElement('li');
        li.className = 'history-entry';
        const label = document.createElement('div');
        const strong = document.createElement('strong');
        strong.textContent = entry.label;
        const small = document.createElement('small');
        small.textContent = new Date(entry.timestamp).toLocaleString();
        const meta = document.createElement('p');
        meta.style.margin = '0.3rem 0 0';
        meta.textContent = `Nodes: ${entry.nodesCount}${entry.reason ? ` ¬∑ ${entry.reason}` : ''}`;
        label.appendChild(strong);
        label.appendChild(small);
        label.appendChild(meta);
        const actions = document.createElement('div');
        actions.className = 'history-actions';
        const restoreBtn = document.createElement('button');
        restoreBtn.type = 'button';
        restoreBtn.textContent = 'Restore';
        restoreBtn.dataset.index = index;
        restoreBtn.dataset.action = 'restore';
        const compareBtn = document.createElement('button');
        compareBtn.type = 'button';
        compareBtn.textContent = 'Compare';
        compareBtn.dataset.index = index;
        compareBtn.dataset.action = 'compare';
        actions.appendChild(restoreBtn);
        actions.appendChild(compareBtn);
        li.appendChild(label);
        li.appendChild(actions);
        historyList.appendChild(li);
      });
    }

    function openHistoryModal() {
      if (!historyModal) return;
      historyModal.classList.remove('hidden');
      historyModal.setAttribute('aria-hidden', 'false');
      renderHistoryList();
      if (historyStatusEl) {
        historyStatusEl.classList.remove('history-status');
        historyStatusEl.textContent = 'Snapshots capture nodes, pan, scale, and serialized DSL/XML.';
      }
    }

    function closeHistoryModal() {
      if (!historyModal) return;
      historyModal.classList.add('hidden');
      historyModal.setAttribute('aria-hidden', 'true');
    }

    function restoreLatestSnapshot() {
      const flow = getActiveFlow();
      const latest = flow?.history?.[0];
      if (!latest) {
        showBanner({ type: 'info', title: 'No snapshots', message: 'Save a snapshot to restore it later.' });
        return;
      }
      restoreSnapshot(latest);
    }

    function saveSnapshot(reason = 'Manual snapshot') {
      if (!activeFlowId) return;
      const flow = getActiveFlow();
      if (!flow) return;
      const snapshotDsl = generateDsl(nodes);
      const entry = {
        id: `${flow.id}-snapshot-${Date.now()}`,
        label: reason,
        timestamp: Date.now(),
        nodes: nodes.map((node) => ({ ...node })),
        panX,
        panY,
        scale,
        selectedId,
        nodesCount: nodes.length,
        dsl: snapshotDsl,
        xml: latestXml,
        mermaid: latestMermaid,
        reason,
      };
      flow.history = [entry, ...(flow.history || [])].slice(0, 10);
      persistFlowHistory(flow);
      updateHistorySummary(flow);
      renderHistoryList();
      markFlowClean();
      historyStatusEl?.classList?.remove('history-status');
    }

    function restoreSnapshot(entry) {
      if (!entry) return;
      replaceActiveFlowNodes(entry.nodes.map((node) => ({ ...node })));
      panX = entry.panX ?? panX;
      panY = entry.panY ?? panY;
      scale = entry.scale ?? scale;
      selectedId = entry.selectedId || null;
      renderAll();
      markFlowClean();
      historyStatusEl.textContent = `Restored snapshot "${entry.label}".`;
      historyStatusEl.className = 'history-status';
      updateEmptyState();
    }

    function compareSnapshot(entry) {
      if (!entry) return;
      const delta = nodes.length - entry.nodesCount;
      const sign = delta > 0 ? '+' : '';
      historyStatusEl.textContent = `Current vs snapshot "${entry.label}": nodes delta ${sign}${delta}.`;
      historyStatusEl.className = 'history-status';
    }

    function renderShortcutLists() {
      if (shortcutSummaryList) {
        shortcutSummaryList.innerHTML = '';
        shortcutDefinitions.slice(0, 4).forEach((item) => {
          const li = document.createElement('li');
          li.className = 'history-entry';
          const strong = document.createElement('strong');
          strong.textContent = item.combo;
          const small = document.createElement('small');
          small.textContent = item.description;
          li.appendChild(strong);
          li.appendChild(small);
          shortcutSummaryList.appendChild(li);
        });
      }
      if (shortcutList) {
        shortcutList.innerHTML = '';
        shortcutDefinitions.forEach((item) => {
          const li = document.createElement('li');
          li.className = 'history-entry';
          const strong = document.createElement('strong');
          strong.textContent = item.combo;
          const small = document.createElement('small');
          small.textContent = item.description;
          li.appendChild(strong);
          li.appendChild(small);
          shortcutList.appendChild(li);
        });
      }
    }

    function refreshShortcutSummaryText() {
      if (!shortcutsSummaryEl) return;
      shortcutsSummaryEl.textContent = shortcutsEnabled
        ? 'Shortcuts accelerate compile, history, templates, and previews.'
        : 'Shortcuts paused. Toggle them to continue using combos.';
    }

    function updateShortcutToggleState() {
      if (toggleShortcutsBtn) {
        toggleShortcutsBtn.textContent = `Shortcuts: ${shortcutsEnabled ? 'On' : 'Off'}`;
        toggleShortcutsBtn.setAttribute('aria-pressed', shortcutsEnabled.toString());
      }
      if (shortcutsStatusEl) {
        shortcutsStatusEl.textContent = `Shortcuts are ${shortcutsEnabled ? 'enabled' : 'disabled'}.`;
      }
      refreshShortcutSummaryText();
    }

    function setShortcutsState(enabled) {
      shortcutsEnabled = enabled;
      localStorage.setItem(SHORTCUTS_STORAGE_KEY, enabled.toString());
      updateShortcutToggleState();
    }

    function openShortcutsPanel() {
      if (!shortcutsModal) return;
      renderShortcutLists();
      shortcutsModal.classList.remove('hidden');
      shortcutsModal.setAttribute('aria-hidden', 'false');
      updateShortcutToggleState();
    }

    function closeShortcutsPanel() {
      if (!shortcutsModal) return;
      shortcutsModal.classList.add('hidden');
      shortcutsModal.setAttribute('aria-hidden', 'true');
    }

    function deleteSelectedNode() {
      if (!selectedId) return;
      const index = nodes.findIndex((n) => n.id === selectedId);
      if (index === -1) return;
      nodes.splice(index, 1);
      selectedId = null;
      renderAll();
      markCurrentFlowDirty();
      updateEmptyState();
      showBanner({
        type: 'info',
        title: 'Node removed',
        message: 'Use the history panel to restore the last snapshot.',
        duration: 4000,
      });
    }

    function nudgeSelectedNode(direction) {
      const node = nodes.find((n) => n.id === selectedId);
      if (!node) return;
      let dx = 0;
      let dy = 0;
      if (direction === 'arrowleft') dx = -SHORTCUT_NUDGE_STEP;
      if (direction === 'arrowright') dx = SHORTCUT_NUDGE_STEP;
      if (direction === 'arrowup') dy = -SHORTCUT_NUDGE_STEP;
      if (direction === 'arrowdown') dy = SHORTCUT_NUDGE_STEP;
      if (dx === 0 && dy === 0) return;
      node.x = (node.x || 0) + dx;
      node.y = (node.y || 0) + dy;
      renderAll();
      markCurrentFlowDirty();
      setPreviewHint('Node nudged via keyboard.', 'info');
    }

    function handleGlobalShortcuts(event) {
      if (event.defaultPrevented || !shortcutsEnabled) return;
      const target = event.target;
      const isInput =
        target instanceof HTMLElement &&
        (['INPUT', 'TEXTAREA', 'SELECT'].includes(target.tagName) || target.isContentEditable);
      if (isInput) return;
      const key = event.key.toLowerCase();
      const isMeta = event.metaKey || event.ctrlKey;
      if (isMeta && key === 's') {
        event.preventDefault();
        compileButton?.click();
        return;
      }
      if (isMeta && key === 't') {
        event.preventDefault();
        openTutorial(0);
        return;
      }
      if (isMeta && key === 'l') {
        event.preventDefault();
        loadTemplate('onboarding');
        setPreviewHint('Onboarding template loaded via shortcut.', 'success');
        return;
      }
      if (isMeta && key === 'p') {
        event.preventDefault();
        renderPreview();
        setPreviewHint('Mermaid preview refreshed via shortcut.', 'success');
        return;
      }
      if (isMeta && key === 'z') {
        event.preventDefault();
        restoreLatestSnapshot();
        return;
      }
      if (isMeta && key === 'y') {
        event.preventDefault();
        openHistoryModal();
        return;
      }
      if (key === 'delete' || key === 'backspace') {
        if (selectedId) {
          event.preventDefault();
          deleteSelectedNode();
        }
        return;
      }
      if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(key)) {
        event.preventDefault();
        nudgeSelectedNode(key);
        return;
      }
    }

    function updateImportStatus(message, tone = 'info') {
      if (!importStatusEl) return;
      importStatusEl.textContent = message;
      importStatusEl.className = `import-status ${tone}`;
    }

    async function importMermaidText(text) {
      updateImportStatus('Compiling Mermaid to DSL...');
      try {
        const res = await fetch(`${API_BASE}/api/compile`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ mermaidText: text }),
        });
        const data = await safeJson(res);
        if (!res.ok || !data.dsl) {
          throw new Error(data?.error || 'Compiler rejected the Mermaid input.');
        }
        loadFlowDsl(data.dsl);
        updateImportStatus('Mermaid loaded into the canvas.', 'success');
      } catch (err) {
        updateImportStatus(`Import failed: ${err.message}`, 'error');
      }
    }

    async function importDslText(text) {
      try {
        const parsed = JSON.parse(text);
        loadFlowDsl(parsed);
        updateImportStatus('DSL loaded into the current flow.', 'success');
      } catch (err) {
        updateImportStatus(`Failed to parse DSL: ${err.message}`, 'error');
      }
    }

    async function importXmlText(text) {
      updateImportStatus('Parsing Flow XML...');
      try {
        const res = await fetch(`${API_BASE}/api/decompile`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ flowXml: text }),
        });
        const data = await safeJson(res);
        if (!res.ok || !data.dsl) {
          throw new Error(data?.error || 'Could not parse Flow XML.');
        }
        loadFlowDsl(data.dsl);
        updateImportStatus('Flow XML imported into the canvas.', 'success');
      } catch (err) {
        updateImportStatus(`Flow XML import failed: ${err.message}`, 'error');
      }
    }

    function flowDslToNodes(dsl) {
      if (!dsl || !Array.isArray(dsl.elements)) return [];
      const perRow = 4;
      const stepX = 220;
      const stepY = 120;
      return dsl.elements.map((elem, idx) => {
        const base = {
          id: elem.apiName || elem.id || `elem-${idx}`,
          apiName: elem.apiName || elem.id || `element_${idx}`,
          label: elem.label || elem.apiName || elem.type,
          type: elem.type,
          x: 80 + (idx % perRow) * stepX,
          y: 80 + Math.floor(idx / perRow) * stepY,
        };
        if (elem.type === 'Decision' && Array.isArray(elem.outcomes)) {
          const yesOutcome = elem.outcomes.find((o) => /yes/i.test(o.name || ''));
          const noOutcome = elem.outcomes.find((o) => o.isDefault || /no/i.test(o.name || ''));
          return {
            ...base,
            yesNext: yesOutcome?.next || elem.next,
            noNext: noOutcome?.next || elem.next,
            outcomes: elem.outcomes,
          };
        }
        if (elem.type === 'Assignment') {
          return {
            ...base,
            assignments: Array.isArray(elem.assignments)
              ? elem.assignments.map((a) => `${a.variable} = ${a.value}`).join('; ')
              : elem.assignments,
            next: elem.next,
          };
        }
        if (elem.type === 'GetRecords') {
          return {
            ...base,
            object: elem.object || '',
            fields: Array.isArray(elem.fields) ? elem.fields.join(', ') : elem.fields,
            next: elem.next,
          };
        }
        if (elem.type === 'Loop') {
          return {
            ...base,
            loopCondition: elem.condition || elem.loopCondition,
            iterationCount: elem.iterations || elem.iterationCount,
            next: elem.next,
          };
        }
        if (elem.type === 'Wait') {
          return {
            ...base,
            waitFor: elem.waitFor || elem.eventName || '',
            waitDuration: elem.duration || elem.waitDuration || '',
            next: elem.next,
          };
        }
        if (elem.type === 'Fault') {
          return {
            ...base,
            faultSource: elem.source || elem.faultSource || '',
            faultMessage: elem.message || elem.faultMessage || '',
            next: elem.next,
          };
        }
        return {
          ...base,
          next: elem.next,
        };
      });
    }

    function loadFlowDsl(dsl) {
      const nodesFromDsl = flowDslToNodes(dsl);
      replaceActiveFlowNodes(nodesFromDsl);
      renderAll();
      markCurrentFlowDirty();
      updateEmptyState();
      setPreviewHint('Imported flow synced to Mermaid & DSL preview.', 'success');
      latestDslData = dsl;
    }

    function downloadBlob(filename, data, type = 'text/plain') {
      const blob = new Blob([data], { type });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function generateSvgSnapshot() {
      if (!nodes || nodes.length === 0) return '';
      const ns = 'http://www.w3.org/2000/svg';
      const width = Math.max(...nodes.map((n) => (n.x || 0))) + 260;
      const height = Math.max(...nodes.map((n) => (n.y || 0))) + 220;
      const svg = document.createElementNS(ns, 'svg');
      svg.setAttribute('xmlns', ns);
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      const defs = document.createElementNS(ns, 'defs');
      const arrow = document.createElementNS(ns, 'marker');
      arrow.setAttribute('id', 'hub-arrow');
      arrow.setAttribute('viewBox', '0 0 10 10');
      arrow.setAttribute('refX', '5');
      arrow.setAttribute('refY', '5');
      arrow.setAttribute('markerWidth', '6');
      arrow.setAttribute('markerHeight', '6');
      arrow.setAttribute('orient', 'auto-start-reverse');
      const path = document.createElementNS(ns, 'path');
      path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
      path.setAttribute('fill', '#66e0ff');
      arrow.appendChild(path);
      defs.appendChild(arrow);
      svg.appendChild(defs);
      const edgeNodes = collectConnections();
      const mapPositions = (node) => ({
        x: (node.x || 0) + 60,
        y: (node.y || 0) + 40,
      });
      edgeNodes.forEach((edge) => {
        const source = nodes.find((n) => n.id === edge.from);
        const target = nodes.find((n) => n.id === edge.to);
        if (!source || !target) return;
        const s = mapPositions(source);
        const t = mapPositions(target);
        const line = document.createElementNS(ns, 'line');
        line.setAttribute('x1', s.x);
        line.setAttribute('y1', s.y);
        line.setAttribute('x2', t.x);
        line.setAttribute('y2', t.y);
        line.setAttribute('stroke', '#66e0ff');
        line.setAttribute('stroke-width', '2');
        line.setAttribute('marker-end', 'url(#hub-arrow)');
        svg.appendChild(line);
        if (edge.label) {
          const text = document.createElementNS(ns, 'text');
          text.setAttribute('x', (s.x + t.x) / 2);
          text.setAttribute('y', (s.y + t.y) / 2 - 6);
          text.setAttribute('fill', '#9aa5d3');
          text.setAttribute('font-size', '12');
          text.textContent = edge.label;
          svg.appendChild(text);
        }
      });
      nodes.forEach((node) => {
        const pos = mapPositions(node);
        const rect = document.createElementNS(ns, 'rect');
        rect.setAttribute('x', (node.x || 0) + 20);
        rect.setAttribute('y', (node.y || 0) + 10);
        rect.setAttribute('width', '140');
        rect.setAttribute('height', '48');
        rect.setAttribute('rx', '12');
        rect.setAttribute('fill', '#1b2546');
        rect.setAttribute('stroke', '#223054');
        svg.appendChild(rect);
        const text = document.createElementNS(ns, 'text');
        text.setAttribute('x', pos.x);
        text.setAttribute('y', pos.y + 5);
        text.setAttribute('fill', '#f5f7ff');
        text.setAttribute('font-size', '12');
        text.setAttribute('text-anchor', 'middle');
        text.textContent = node.label || node.apiName || node.type;
        svg.appendChild(text);
      });
      return new XMLSerializer().serializeToString(svg);
    }

    async function generatePngSnapshot() {
      if (!nodes || nodes.length === 0) return '';
      const canvas = document.createElement('canvas');
      const offsetX = Math.max(0, -(Math.min(...nodes.map((n) => n.x || 0))) + 40);
      const offsetY = Math.max(0, -(Math.min(...nodes.map((n) => n.y || 0))) + 40);
      const width = Math.max(...nodes.map((n) => (n.x || 0))) + offsetX + 200;
      const height = Math.max(...nodes.map((n) => (n.y || 0))) + offsetY + 200;
      canvas.width = Math.max(400, width);
      canvas.height = Math.max(300, height);
      const ctx = canvas.getContext('2d');
      if (!ctx) return '';
      ctx.fillStyle = '#090f1f';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = '#66e0ff';
      ctx.lineWidth = 2;
      const nodePositions = nodes.map((node) => ({
        id: node.id,
        x: (node.x || 0) + offsetX + 70,
        y: (node.y || 0) + offsetY + 40,
      }));
      collectConnections().forEach((edge) => {
        const source = nodePositions.find((p) => p.id === edge.from);
        const target = nodePositions.find((p) => p.id === edge.to);
        if (!source || !target) return;
        ctx.beginPath();
        ctx.moveTo(source.x, source.y);
        ctx.lineTo(target.x, target.y);
        ctx.stroke();
      });
      ctx.fillStyle = '#1b2546';
      ctx.strokeStyle = '#223054';
      nodePositions.forEach((pos) => {
        ctx.fillRect(pos.x - 70, pos.y - 24, 140, 48);
        ctx.strokeRect(pos.x - 70, pos.y - 24, 140, 48);
        ctx.fillStyle = '#f5f7ff';
        ctx.font = '12px Inter';
        ctx.textAlign = 'center';
        ctx.fillText(nodes.find((n) => n.id === pos.id)?.label || pos.id, pos.x, pos.y + 5);
        ctx.fillStyle = '#1b2546';
      });
      return canvas.toDataURL('image/png');
    }

    function saveCurrentFlowState() {
      if (!activeFlowId) return;
      const flow = flowBuffers.get(activeFlowId);
      if (!flow) return;
      flow.nodes = nodes;
      flow.panX = panX;
      flow.panY = panY;
      flow.scale = scale;
      flow.selectedId = selectedId;
    }

    function markFlowDirty(id, dirty = true) {
      const flow = flowBuffers.get(id);
      if (!flow) return;
      flow.dirty = dirty;
      renderFlowTabs();
    }

    function markCurrentFlowDirty() {
      markFlowDirty(activeFlowId, true);
    }

    function markFlowClean(id = activeFlowId) {
      markFlowDirty(id, false);
    }

    function renderFlowTabs() {
      if (!flowTabs) return;
      flowTabs.innerHTML = '';
      flowBuffers.forEach((flow) => {
        const tab = document.createElement('button');
        tab.type = 'button';
        tab.className = 'flow-tab';
        if (flow.id === activeFlowId) tab.classList.add('active');
        const label = document.createElement('span');
        label.textContent = flow.name;
        tab.appendChild(label);
        if (flow.dirty) {
          const indicator = document.createElement('span');
          indicator.className = 'flow-indicator';
          tab.appendChild(indicator);
        }
        tab.addEventListener('click', () => loadFlow(flow.id));
        flowTabs.appendChild(tab);
      });
    }

    function createFlow(name, nodesSnapshot = sampleNodes) {
      const label = name || `Flow ${flowCounter++}`;
      const id = `flow-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
      const nodeCopy = nodesSnapshot.map((n) => ({ ...n }));
      const flow = {
        id,
        name: label,
        nodes: nodeCopy,
        panX: 0,
        panY: 0,
        scale: 1,
        selectedId: null,
        dirty: false,
        history: loadStoredHistory(id),
      };
      flowBuffers.set(id, flow);
      renderFlowTabs();
      return flow;
    }

    function replaceActiveFlowNodes(newNodes) {
      const flow = flowBuffers.get(activeFlowId);
      if (flow) {
        flow.nodes = newNodes;
      }
      nodes = newNodes;
    }

    function loadFlow(id) {
      if (!flowBuffers.has(id)) return;
      if (id === activeFlowId) return;
      saveCurrentFlowState();
      activeFlowId = id;
      const flow = flowBuffers.get(id);
      flow.history = flow.history || loadStoredHistory(id);
      nodes = flow.nodes;
      panX = flow.panX;
      panY = flow.panY;
      scale = flow.scale;
      selectedId = flow.selectedId || null;
      renderFlowTabs();
      renderAll();
      updateEmptyState();
      updateHistorySummary(flow);
      renderHistoryList();
    }

    newFlowBtn?.addEventListener('click', () => {
      const flow = createFlow();
      loadFlow(flow.id);
    });

    function requestRender() {
      if (renderPending) return;
      renderPending = true;
      requestAnimationFrame(() => {
        renderList();
        renderCanvas();
        renderPreview();
        renderForm();
        renderPending = false;
      });
    }

    function updateEmptyState() {
      if (!emptyOverlay) return;
      emptyOverlay.hidden = nodes.length > 0;
    }

    function setIssueState(level, entries = []) {
      if (!statusDetails || !statusDetailsSummary || !statusDetailsList) return;
      statusDetails.dataset.level = level;
      statusDetailsSummary.textContent = entries.length ? entries[0] : 'No active issues.';
      statusDetailsSummary.className = `inline-status ${level}`;
      statusDetailsList.innerHTML = '';
      entries.forEach((entry) => {
        const li = document.createElement('li');
        li.textContent = entry;
        statusDetailsList.appendChild(li);
      });
    }

    function clearIssueState() {
      setIssueState('info', []);
    }

    function applyAdvancedHighlight() {
      document.querySelectorAll('.node').forEach((el) => {
        const matches = el.dataset.nodeType === activeAdvancedType;
        el.classList.toggle('advanced-highlight', Boolean(activeAdvancedType && matches));
      });
      if (advancedHelper) {
        advancedHelper.textContent = activeAdvancedType
          ? `Highlighting ${activeAdvancedType} nodes.`
          : 'Click a pill to highlight Loop, Wait, or Fault nodes.';
      }
    }

    function highlightAdvancedNodes(type) {
      activeAdvancedType = type === 'clear' ? null : type;
      advancedButtons.forEach((btn) => {
        btn.classList.toggle('active', btn.dataset.advancedTarget === activeAdvancedType);
      });
      applyAdvancedHighlight();
    }

    function highlightTutorialTarget(selector) {
      if (!tutorialHighlight) return;
      const target = selector ? document.querySelector(selector) : null;
      if (!target) {
        tutorialHighlight.hidden = true;
        return;
      }
      const rect = target.getBoundingClientRect();
      tutorialHighlight.hidden = false;
      tutorialHighlight.style.width = `${rect.width + 18}px`;
      tutorialHighlight.style.height = `${rect.height + 18}px`;
      tutorialHighlight.style.left = `${rect.left - 9 + window.scrollX}px`;
      tutorialHighlight.style.top = `${rect.top - 9 + window.scrollY}px`;
    }

    function openTutorial(startAt = 0) {
      if (!tutorialOverlay) return;
      tutorialActive = true;
      tutorialOverlay.classList.remove('hidden');
      tutorialOverlay.setAttribute('aria-hidden', 'false');
      tutorialStep = startAt;
      updateTutorialStep();
    }

    function closeTutorial() {
      if (!tutorialOverlay) return;
      tutorialActive = false;
      tutorialOverlay.classList.add('hidden');
      tutorialOverlay.setAttribute('aria-hidden', 'true');
      if (tutorialHighlight) {
        tutorialHighlight.hidden = true;
      }
    }

    function updateTutorialStep() {
      if (!tutorialTitle || !tutorialDescription || !tutorialProgress || !tutorialNext || !tutorialPrev) return;
      const step = tutorialSteps[tutorialStep];
      tutorialTitle.textContent = step.title;
      tutorialDescription.textContent = step.description;
      tutorialProgress.textContent = `${tutorialStep + 1}/${tutorialSteps.length}`;
      tutorialPrev.disabled = tutorialStep === 0;
      tutorialNext.textContent = tutorialStep === tutorialSteps.length - 1 ? 'Finish' : 'Next';
      highlightTutorialTarget(step.selector);
    }

    function navigateTutorial(delta) {
      tutorialStep = Math.max(0, Math.min(tutorialSteps.length - 1, tutorialStep + delta));
      updateTutorialStep();
    }

    function snapToGrid(value, step = 20) {
      return Math.round(value / step) * step;
    }

    async function safeJson(res) {
      const text = await res.text();
      if (!text) return {};
      try {
        return JSON.parse(text);
      } catch (err) {
        throw new Error(`Unexpected response (${res.status}): ${text.slice(0, 160)}`);
      }
    }

    const sampleNodes = [
      { id: 'Start_1', type: 'Start', label: 'Demo Start', apiName: 'Start_1', next: 'Screen_1', x: 80, y: 60 },
      { id: 'Screen_1', type: 'Screen', label: 'Collect Data', apiName: 'Screen_1', next: 'Decision_1', x: 320, y: 60 },
      { id: 'Decision_1', type: 'Decision', label: 'Route', apiName: 'Decision_1', yesNext: 'Assign_1', noNext: 'End_1', x: 560, y: 60 },
      { id: 'Assign_1', type: 'Assignment', label: 'Set Flag', apiName: 'Assign_1', next: 'End_1', assignments: 'v_Flag = true', x: 800, y: 40 },
      { id: 'End_1', type: 'End', label: 'Done', apiName: 'End_1', x: 800, y: 160 },
    ];

    const templates = {
      onboarding: {
        name: 'Customer Onboarding',
        description: 'Screen + Decision + Record create/update + Email subflow',
        nodes: [
          { id: 'Start_1', type: 'Start', label: 'Start', apiName: 'Start_1', next: 'Screen_1', x: 60, y: 80 },
          { id: 'Screen_1', type: 'Screen', label: 'Collect Info', apiName: 'Screen_1', next: 'Decision_1', x: 260, y: 80 },
          { id: 'Decision_1', type: 'Decision', label: 'Existing Customer?', apiName: 'Decision_1', yesNext: 'Update_1', noNext: 'Create_1', x: 480, y: 80 },
          { id: 'Create_1', type: 'RecordCreate', label: 'Create Account', apiName: 'Create_1', next: 'Email_1', x: 700, y: 20 },
          { id: 'Update_1', type: 'RecordUpdate', label: 'Update Account', apiName: 'Update_1', next: 'Email_1', x: 700, y: 140 },
          { id: 'Email_1', type: 'Subflow', label: 'Send Welcome Email', apiName: 'Email_1', next: 'End_1', x: 920, y: 80 },
          { id: 'End_1', type: 'End', label: 'Done', apiName: 'End_1', x: 1120, y: 80 },
        ],
      },
      lead: {
        name: 'Lead Routing',
        description: 'Decision + Assignment + GetRecords to route leads',
        nodes: [
          { id: 'Start_1', type: 'Start', label: 'Start', apiName: 'Start_1', next: 'Decision_1', x: 60, y: 80 },
          { id: 'Decision_1', type: 'Decision', label: 'Qualified?', apiName: 'Decision_1', yesNext: 'Assign_1', noNext: 'End_1', x: 260, y: 80 },
          { id: 'Assign_1', type: 'Assignment', label: 'Set Owner', apiName: 'Assign_1', assignments: 'Owner = Queue', next: 'Get_1', x: 500, y: 30 },
          { id: 'Get_1', type: 'GetRecords', label: 'Lookup Lead', apiName: 'Get_1', next: 'End_1', x: 740, y: 80 },
          { id: 'End_1', type: 'End', label: 'Done', apiName: 'End_1', x: 980, y: 80 },
        ],
      },
      case: {
        name: 'Case Escalation',
        description: 'Screen + Decision + Wait/Fault connectors simplified',
        nodes: [
          { id: 'Start_1', type: 'Start', label: 'Start', apiName: 'Start_1', next: 'Screen_1', x: 60, y: 80 },
          { id: 'Screen_1', type: 'Screen', label: 'Capture Case', apiName: 'Screen_1', next: 'Decision_1', x: 260, y: 80 },
          { id: 'Decision_1', type: 'Decision', label: 'Severity?', apiName: 'Decision_1', yesNext: 'Assign_1', noNext: 'Wait_1', x: 480, y: 80 },
          { id: 'Assign_1', type: 'Assignment', label: 'Escalate Owner', apiName: 'Assign_1', assignments: 'Owner = Tier2', next: 'End_1', x: 700, y: 20 },
          { id: 'Wait_1', type: 'Wait', label: 'Follow-up', apiName: 'Wait_1', next: 'End_1', x: 700, y: 140 },
          { id: 'End_1', type: 'End', label: 'Complete', apiName: 'End_1', x: 920, y: 80 },
        ],
      },
      resilience: {
        name: 'Resilient Loop Path',
        description: 'Loop + Fault handling with wait checks',
        nodes: [
          { id: 'Start_1', type: 'Start', label: 'Start', apiName: 'Start_1', next: 'Screen_1', x: 60, y: 60 },
          { id: 'Screen_1', type: 'Screen', label: 'Check System', apiName: 'Screen_1', next: 'Loop_1', x: 260, y: 60 },
          { id: 'Loop_1', type: 'Loop', label: 'Retry Loop', apiName: 'Loop_1', next: 'Decision_1', loopCondition: 'Retry < 3', iterationCount: '3', x: 460, y: 60 },
          { id: 'Decision_1', type: 'Decision', label: 'Success?', apiName: 'Decision_1', yesNext: 'End_1', noNext: 'Wait_1', x: 660, y: 60 },
          { id: 'Wait_1', type: 'Wait', label: 'Delay', apiName: 'Wait_1', next: 'Fault_1', waitFor: 'External signal', waitDuration: '00:01:00', x: 660, y: 200 },
          { id: 'Fault_1', type: 'Fault', label: 'Catch Error', apiName: 'Fault_1', next: 'End_1', faultSource: 'API', faultMessage: 'Retry required', x: 460, y: 200 },
          { id: 'End_1', type: 'End', label: 'Done', apiName: 'End_1', x: 920, y: 80 },
        ],
      },
    };

    const iconMap = {
      Start: '‚ñ∂',
      End: '‚èπ',
      Screen: 'üìã',
      Decision: 'üîÄ',
      Assignment: '‚úèÔ∏è',
      RecordCreate: '‚ûï',
      RecordUpdate: 'üõ†',
      GetRecords: 'üìä',
      Subflow: 'üîÅ',
      Loop: '‚ü≥',
      Wait: '‚è≥',
      Fault: '‚ö†Ô∏è',
      default: '‚¨¢',
    };

    const typeDefaults = {
      Start: () => ({ type: 'Start', label: 'Start', next: '' }),
      End: () => ({ type: 'End', label: 'End' }),
      Screen: () => ({ type: 'Screen', label: 'Screen', next: '' }),
      Assignment: () => ({ type: 'Assignment', label: 'Assignment', assignments: '', next: '' }),
      Decision: () => ({ type: 'Decision', label: 'Decision', yesNext: '', noNext: '' }),
      GetRecords: () => ({ type: 'GetRecords', label: 'Get Records', object: '', fields: '', filters: '', next: '' }),
      Loop: () => ({ type: 'Loop', label: 'Loop', next: '', loopCondition: '', iterationCount: '' }),
      Wait: () => ({ type: 'Wait', label: 'Wait', next: '', waitFor: '', waitDuration: '' }),
      Fault: () => ({ type: 'Fault', label: 'Fault', next: '', faultSource: '', faultMessage: '' }),
    };

    function init() {
      const defaultFlow = createFlow('Default Flow', sampleNodes);
      renderTemplates();
      restoreTheme();
      renderShortcutLists();
      setShortcutsState(shortcutsEnabled);
      loadFlow(defaultFlow.id);
      clearIssueState();
      highlightAdvancedNodes('clear');
      updateEmptyState();
      setLoadingState(false, '');
    }

    function renderAll() {
      renderList();
      renderCanvas();
      renderPreview();
      renderForm();
    }

    function applyTransform() {
      canvasInner.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    }

    function renderList() {
      list.innerHTML = '';
      nodes.forEach((n) => {
        const li = document.createElement('li');
        li.draggable = true;
        li.dataset.id = n.id;
        const icon = iconMap[n.type] || iconMap.default;
        li.innerHTML = `<div style="display:flex; align-items:center; gap:0.4rem;"><span>${icon}</span>${n.id}</div><span class="pill"><span>${icon}</span>${n.type}</span>`;
        li.addEventListener('click', () => {
          selectedId = n.id;
          renderForm();
        });
        li.addEventListener('dragstart', (e) => {
          li.classList.add('dragging');
          e.dataTransfer.setData('text/plain', n.id);
        });
        li.addEventListener('dragend', () => li.classList.remove('dragging'));
        list.appendChild(li);
      });
      list.addEventListener('dragover', (e) => {
        e.preventDefault();
        const dragging = document.querySelector('.dragging');
        const afterElement = getDragAfterElement(list, e.clientY);
        if (!dragging) return;
        if (afterElement == null) {
          list.appendChild(dragging);
        } else {
          list.insertBefore(dragging, afterElement);
        }
      });
      list.addEventListener('drop', () => {
        const newOrder = Array.from(list.children).map((li) => li.dataset.id);
        nodes.sort((a, b) => newOrder.indexOf(a.id) - newOrder.indexOf(b.id));
        renderAll();
      });
    }

    function renderTemplates() {
      if (!templateGrid) return;
      templateGrid.innerHTML = '';
      Object.entries(templates).forEach(([key, tpl]) => {
        const div = document.createElement('div');
        div.className = 'template-card';
        div.innerHTML = `
          <header>
            <div>
              <strong>${tpl.name}</strong><br/>
              <small>${tpl.description}</small>
            </div>
            <span class="pill">Template</span>
          </header>
          <div class="row" style="margin-top:0.5rem;">
            <button data-use="${key}" aria-label="Use template ${tpl.name}">Use</button>
            <button class="secondary" data-preview="${key}" aria-label="Preview template ${tpl.name}">Preview</button>
          </div>
        `;
        const useBtn = div.querySelector('[data-use]');
        const previewBtn = div.querySelector('[data-preview]');
        useBtn.addEventListener('click', (evt) => {
          const btn = evt.currentTarget;
          setButtonLoading(btn, true, 'Loading...');
          requestAnimationFrame(() => {
            loadTemplate(key);
            setButtonLoading(btn, false);
          });
        });
          previewBtn.addEventListener('click', (evt) => {
            const btn = evt.currentTarget;
            setButtonLoading(btn, true, 'Previewing...');
            setLoadingState(true, 'Rendering preview...');
            requestAnimationFrame(() => {
              replaceActiveFlowNodes([...templates[key].nodes]);
              renderAll();
              markCurrentFlowDirty();
              setButtonLoading(btn, false);
              setLoadingState(false);
              setPreviewHint(`Previewing ${tpl.name}. Use the compile action to turn it into XML.`, 'info');
              showBanner({
                type: 'info',
                title: 'Template preview',
                message: `${tpl.name} is rendering in the canvas.`,
                duration: 2500,
              });
            });
          });
        templateGrid.appendChild(div);
      });
    }

    function loadTemplate(key) {
      const tpl = templates[key];
      if (!tpl) return;
      setLoadingState(true, 'Loading template...');
      requestAnimationFrame(() => {
        replaceActiveFlowNodes(JSON.parse(JSON.stringify(tpl.nodes)));
        selectedId = null;
        renderAll();
        markCurrentFlowDirty();
        scrollToBuilder();
        output.textContent = `Template loaded: ${tpl.name}`;
        setPreviewHint(`Loaded template "${tpl.name}". Loops/Waits/Faults keep their metadata in the preview.`, 'success');
        showBanner({
          type: 'success',
          title: 'Template ready',
          message: `${tpl.name} loaded into the canvas.`,
        });
        setLoadingState(false);
      });
    }

    function scrollToBuilder() {
      const builder = document.querySelector('main');
      if (builder) builder.scrollIntoView({ behavior: 'smooth' });
    }

    function getDragAfterElement(container, y) {
      const elements = [...container.querySelectorAll('li:not(.dragging)')];
      return elements.reduce(
        (closest, child) => {
          const box = child.getBoundingClientRect();
          const offset = y - box.top - box.height / 2;
          if (offset < 0 && offset > closest.offset) {
            return { offset, element: child };
          } else {
            return closest;
          }
        },
        { offset: Number.NEGATIVE_INFINITY, element: null },
      ).element;
    }

    function renderCanvas() {
      canvasInner.innerHTML = '';
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.classList.add('edges');
      canvasInner.appendChild(svg);

      nodes.forEach((n) => {
        const icon = iconMap[n.type] || iconMap.default;
        const div = document.createElement('div');
        let cls = 'node default';
        if (n.type === 'Start') cls = 'node start';
        else if (n.type === 'End') cls = 'node end';
        else if (n.type === 'Decision') cls = 'node decision';
        div.className = cls;
        div.innerHTML = `<span>${icon}</span><span>${n.id}: ${n.label || n.apiName || n.type}</span>`;
        const tooltip = createNodeTooltip(n);
        if (tooltip) div.appendChild(tooltip);
        div.style.transform = `translate(${n.x || 0}px, ${(n.y || 0)}px)`;
        div.setAttribute('role', 'button');
        div.setAttribute('aria-label', `${n.type} node ${n.label || n.id}`);
        div.dataset.nodeType = n.type;
        div.dataset.nodeId = n.id;
        div.addEventListener('mousedown', (e) => startNodeDrag(e, n.id));
        div.addEventListener('mouseenter', () => {
          hoverHighlightId = n.id;
          updateEdgeHighlight();
        });
        div.addEventListener('mouseleave', () => {
          hoverHighlightId = null;
          updateEdgeHighlight();
        });
        div.addEventListener('click', () => {
          selectedId = n.id;
          renderForm();
          updateEdgeHighlight();
        });
        canvasInner.appendChild(div);
      });

      updateEmptyState();
      drawEdges(svg);
      edgeSvg = svg;
      updateEdgeHighlight();
      applyTransform();
    }

    function drawEdges(svg) {
      const rect = canvasInner.getBoundingClientRect();
      const nodeMap = new Map();
      canvasInner.querySelectorAll('.node').forEach((el) => {
        const id = el.textContent.split(':')[0].trim();
        const box = el.getBoundingClientRect();
        nodeMap.set(id, {
          x: box.left - rect.left + box.width / 2,
          y: box.top - rect.top + box.height / 2,
        });
      });
      const edges = collectConnections();
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
      marker.setAttribute('id', 'arrow');
      marker.setAttribute('viewBox', '0 0 10 10');
      marker.setAttribute('refX', '5');
      marker.setAttribute('refY', '5');
      marker.setAttribute('markerWidth', '6');
      marker.setAttribute('markerHeight', '6');
      marker.setAttribute('orient', 'auto-start-reverse');
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
      path.setAttribute('fill', '#66e0ff99');
      marker.appendChild(path);
      defs.appendChild(marker);
      svg.prepend(defs);
      edges.forEach(({ from, to, label }) => {
        const a = nodeMap.get(from);
        const b = nodeMap.get(to);
        if (!a || !b) return;
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.classList.add('edge-line');
        line.dataset.from = from;
        line.dataset.to = to;
        line.setAttribute('x1', a.x);
        line.setAttribute('y1', a.y);
        line.setAttribute('x2', b.x);
        line.setAttribute('y2', b.y);
        line.setAttribute('marker-end', 'url(#arrow)');
        line.addEventListener('mouseenter', () => line.classList.add('highlight'));
        line.addEventListener('mouseleave', () => updateEdgeHighlight());
        svg.appendChild(line);
        if (label) {
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.classList.add('edge-label');
          text.setAttribute('x', (a.x + b.x) / 2);
          text.setAttribute('y', (a.y + b.y) / 2 - 6);
          text.textContent = label;
          svg.appendChild(text);
        }
      });
    }

    function collectConnections() {
      const edges = [];
      nodes.forEach((n, idx) => {
        const pushEdge = (toId, label) => {
          if (!toId) return;
          edges.push({ from: n.id, to: toId, label });
        };
        if (n.type === 'Decision') {
          pushEdge(n.yesNext, 'Yes');
          pushEdge(n.noNext, 'No/default');
        } else if (n.type === 'Loop') {
          pushEdge(n.next || (idx < nodes.length - 1 ? nodes[idx + 1].id : null), getAdvancedConnectionLabel(n));
        } else if (n.type === 'Wait') {
          pushEdge(n.next || (idx < nodes.length - 1 ? nodes[idx + 1].id : null), getAdvancedConnectionLabel(n));
        } else if (n.type === 'Fault') {
          pushEdge(n.next || (idx < nodes.length - 1 ? nodes[idx + 1].id : null), getAdvancedConnectionLabel(n));
        } else if (n.next) {
          pushEdge(n.next, '');
        } else if (!n.next && idx < nodes.length - 1 && n.type !== 'End') {
          pushEdge(nodes[idx + 1].id, 'Auto');
        }
      });
      return edges;
    }

    function getAdvancedConnectionLabel(node) {
      if (!node) return '';
      if (node.type === 'Loop') {
        return `Loop: ${node.loopCondition || 'auto'} ¬∑ ${node.iterationCount || 'auto'} iterations`;
      }
      if (node.type === 'Wait') {
        return `Wait: ${node.waitFor || 'signal'} ¬∑ ${node.waitDuration || 'auto'}`;
      }
      if (node.type === 'Fault') {
        return `Fault: ${node.faultSource || 'error'} ¬∑ ${node.faultMessage || 'recover'}`;
      }
      return '';
    }

    function createNodeTooltip(node) {
      const text = getAdvancedTooltipText(node);
      if (!text) return null;
      const span = document.createElement('span');
      span.className = 'node-tooltip';
      span.textContent = text;
      return span;
    }

    function getAdvancedTooltipText(node) {
      if (!node) return '';
      if (node.type === 'Loop') {
        return `Loop cond: ${node.loopCondition || 'auto'}, iterations: ${node.iterationCount || 'auto'}`;
      }
      if (node.type === 'Wait') {
        return `Wait for: ${node.waitFor || 'signal'}, duration: ${node.waitDuration || 'auto'}`;
      }
      if (node.type === 'Fault') {
        return `Fault from ${node.faultSource || 'unexpected source'}: ${node.faultMessage || 'require retry'}`;
      }
      return '';
    }

    function updateEdgeHighlight() {
      if (!edgeSvg) return;
      const active = hoverHighlightId || selectedId;
      edgeSvg.querySelectorAll('.edge-line').forEach((line) => {
        if (line.matches(':hover')) return;
        const isConnected = Boolean(active && (line.dataset.from === active || line.dataset.to === active));
        line.classList.toggle('highlight', isConnected);
      });
    }

    function startNodeDrag(e, id) {
      draggingNode = nodes.find((n) => n.id === id);
      if (!draggingNode) return;
      const rect = canvasInner.getBoundingClientRect();
      const nodeRect = e.currentTarget.getBoundingClientRect();
      dragOffset = {
        x: e.clientX - nodeRect.left + rect.left,
        y: e.clientY - nodeRect.top + rect.top,
      };
      window.addEventListener('mousemove', onNodeDrag);
      window.addEventListener('mouseup', endNodeDrag);
      e.preventDefault();
    }

    function onNodeDrag(e) {
      if (!draggingNode) return;
      const rect = canvasInner.getBoundingClientRect();
      draggingNode.x = e.clientX - rect.left - (dragOffset.x - rect.left);
      draggingNode.y = e.clientY - rect.top - (dragOffset.y - rect.top);
      requestRender();
    }

    function endNodeDrag() {
      if (draggingNode) {
        draggingNode.x = snapToGrid(draggingNode.x);
        draggingNode.y = snapToGrid(draggingNode.y);
      }
      draggingNode = null;
      window.removeEventListener('mousemove', onNodeDrag);
      window.removeEventListener('mouseup', endNodeDrag);
      renderPreview();
    }

    function setScale(next) {
      scale = Math.min(2, Math.max(0.4, next));
      applyTransform();
    }

    function renderForm() {
      const node = nodes.find((n) => n.id === selectedId);
      if (!node) {
        editorCard.style.display = 'none';
        form.innerHTML = '';
        return;
      }
      editorCard.style.display = 'block';
      form.innerHTML = '';
      renderModal(node);
    }

    function inputField(labelText, value, onChange, type = 'text', options = {}) {
      const wrap = document.createElement('div');
      wrap.className = 'modal-field';
      const lab = document.createElement('label');
      lab.textContent = labelText;
      const input = document.createElement('input');
      input.type = type;
      input.value = value;
      const helper = document.createElement('small');
      helper.className = 'field-helper';
      helper.textContent = options.helpText || '';
      const error = document.createElement('small');
      error.className = 'field-error';
      input.addEventListener('input', (e) => {
        error.textContent = '';
        error.style.display = 'none';
        onChange(e.target.value);
      });
      wrap.appendChild(lab);
      wrap.appendChild(input);
      if (options.helpText) wrap.appendChild(helper);
      wrap.appendChild(error);
      return {
        wrap,
        input,
        setError(msg) {
          error.textContent = msg || '';
          error.style.display = msg ? 'block' : 'none';
        },
      };
    }

    function renderPreview() {
      if (nodes.length === 0) {
        mermaidPreview.textContent = 'No diagram yet. Add nodes to see a Mermaid preview.';
        setPreviewHint('Use the toolbox or templates to add Start/Screen nodes; advanced nodes will show condition metadata here.', 'info');
        return;
      }
      const mermaid = generateMermaid(nodes);
      mermaidPreview.textContent = mermaid;
      setPreviewHint('The Mermaid preview reflects Loop/Wait/Fault metadata: hover the nodes in the sidebar for quick tips.', 'info');
    }

    function renderModal(node) {
      closeModal();
      modalEl = document.createElement('div');
      modalEl.className = 'modal-backdrop';
      modalEl.innerHTML = `
        <div class="modal" role="dialog" aria-modal="true" aria-label="Edit ${node.type} node">
          <header>
            <h3 style="margin:0;">Edit ${node.type}</h3>
            <button class="secondary" id="closeModal" aria-label="Close edit dialog">‚úï</button>
          </header>
          <div id="modalBody"></div>
          <div class="row" style="margin-top:0.5rem;">
            <button class="secondary" id="cancelModal">Cancel</button>
            <button id="saveModal">Save</button>
          </div>
        </div>
      `;
      modalEl.addEventListener('click', (e) => {
        if (e.target === modalEl) closeModal();
      });
      document.body.appendChild(modalEl);
      const body = modalEl.querySelector('#modalBody');
      const labelField = inputField('Label', node.label || '', (v) => (node.label = v));
      const apiField = inputField(
        'API Name',
        node.apiName || '',
        (v) => (node.apiName = v),
        'text',
        { helpText: 'Alphanumeric + underscores, start with a letter or underscore.' },
      );
      const xField = inputField('X', node.x ?? 0, (v) => (node.x = Number(v) || 0), 'number');
      const yField = inputField('Y', node.y ?? 0, (v) => (node.y = Number(v) || 0), 'number');
      body.appendChild(labelField.wrap);
      body.appendChild(apiField.wrap);
      body.appendChild(xField.wrap);
      body.appendChild(yField.wrap);

      const connectorHelp = 'Select the node that should run after this one.';
      if (node.type !== 'End' && node.type !== 'Decision') {
        const nextSelect = targetSelect('Next', node.next || '', (v) => (node.next = v), {
          helpText: connectorHelp,
        });
        body.appendChild(nextSelect.wrap);
      }
      if (node.type === 'Decision') {
        const yesSelect = targetSelect('Yes Next', node.yesNext || '', (v) => (node.yesNext = v), {
          helpText: 'Default outcome is "Yes" unless branching differently.',
        });
        const noSelect = targetSelect('No/Default Next', node.noNext || '', (v) => (node.noNext = v), {
          helpText: 'Salesforce requires one default outcome; select the node that should run when no other condition matches.',
        });
        body.appendChild(yesSelect.wrap);
        body.appendChild(noSelect.wrap);
      }

      if (node.type === 'Assignment') {
        const assignmentField = inputField('Assignments (text)', node.assignments || '', (v) => (node.assignments = v), 'text', {
          helpText: 'Use format `Var = value`; multiple assignments can be separated by `;`.',
        });
        body.appendChild(assignmentField.wrap);
      }
      if (node.type === 'GetRecords') {
        const objectField = inputField('Object', node.object || '', (v) => (node.object = v), 'text', {
          helpText: 'Use API name (Account, Case, etc.).',
        });
        const fieldsField = inputField('Fields (comma)', node.fields || '', (v) => (node.fields = v), 'text', {
          helpText: 'List output fields, comma separated.',
        });
        const filtersField = inputField('Filters (key=value;)', node.filters || '', (v) => (node.filters = v), 'text', {
          helpText: 'Use `Field=Value;` pairs for where clause (simplified).',
        });
        body.appendChild(objectField.wrap);
        body.appendChild(fieldsField.wrap);
        body.appendChild(filtersField.wrap);
      }
      if (node.type === 'Loop') {
        body.appendChild(createContextualHelp('Loop nodes let you retry a path; configure condition + iteration guard.'));
        const loopConditionField = inputField('Loop condition', node.loopCondition || '', (v) => (node.loopCondition = v), 'text', {
          helpText: 'Simple expression that determines whether to keep looping.',
        });
        const iterationField = inputField('Max iterations', node.iterationCount || '', (v) => (node.iterationCount = v), 'number', {
          helpText: 'Set a safety limit to avoid infinite loops.',
        });
        body.appendChild(loopConditionField.wrap);
        body.appendChild(iterationField.wrap);
      }
      if (node.type === 'Wait') {
        body.appendChild(createContextualHelp('Wait nodes pause the flow until a duration or signal is met.'));
        const waitForField = inputField('Wait for', node.waitFor || '', (v) => (node.waitFor = v), 'text', {
          helpText: 'Signal or record change that should fire the wait.',
        });
        const durationField = inputField('Duration', node.waitDuration || '', (v) => (node.waitDuration = v), 'text', {
          helpText: 'Time span (HH:MM:SS) or label (e.g., `auto`).',
        });
        body.appendChild(waitForField.wrap);
        body.appendChild(durationField.wrap);
      }
      if (node.type === 'Fault') {
        body.appendChild(createContextualHelp('Fault nodes capture errors and route to recovery paths.'));
        const sourceField = inputField('Fault source', node.faultSource || '', (v) => (node.faultSource = v), 'text', {
          helpText: 'Describe the fault source (API, Record, etc.).',
        });
        const messageField = inputField('Fault message', node.faultMessage || '', (v) => (node.faultMessage = v), 'text', {
          helpText: 'Friendly message shown in status banners.',
        });
        body.appendChild(sourceField.wrap);
        body.appendChild(messageField.wrap);
      }

      modalEl.querySelector('#closeModal').addEventListener('click', closeModal);
      modalEl.querySelector('#cancelModal').addEventListener('click', closeModal);
      modalEl.querySelector('#saveModal').addEventListener('click', () => {
        let valid = true;
        if (!labelField.input.value.trim()) {
          labelField.setError('Label is required.');
          valid = false;
        }
        const apiValue = apiField.input.value.trim();
        if (!apiValue) {
          apiField.setError('API Name is required.');
          valid = false;
        } else if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(apiValue)) {
          apiField.setError('Use letters, numbers, underscores; must start with letter or underscore.');
          valid = false;
        }
        if (!valid) return;
        node.label = labelField.input.value.trim();
        node.apiName = apiValue;
        node.x = Number(xField.input.value) || 0;
        node.y = Number(yField.input.value) || 0;
        closeModal();
        renderAll();
        markCurrentFlowDirty();
      });
    }

    function targetSelect(labelText, value, onChange, options = {}) {
      const wrap = document.createElement('div');
      wrap.className = 'modal-field';
      const lab = document.createElement('label');
      lab.textContent = labelText;
      const sel = document.createElement('select');
      sel.innerHTML = `<option value=\"\">(none)</option>` + nodes
        .map((n) => `<option value=\"${n.id}\" ${value === n.id ? 'selected' : ''}>${n.id} (${n.type})</option>`)
        .join('');
      sel.addEventListener('change', (e) => onChange(e.target.value));
      wrap.appendChild(lab);
      wrap.appendChild(sel);
      if (options.helpText) {
        const helper = document.createElement('small');
        helper.className = 'field-helper';
        helper.textContent = options.helpText;
        wrap.appendChild(helper);
      }
      return { wrap, select: sel };
    }

    function createContextualHelp(text) {
      const el = document.createElement('p');
      el.className = 'context-help';
      el.textContent = text;
      return el;
    }

    function closeModal() {
      if (modalEl && modalEl.parentNode) {
        modalEl.parentNode.removeChild(modalEl);
        modalEl = null;
      }
    }

    function highlightXmlBlock() {
      if (typeof Prism === 'undefined') return;
      const block = document.getElementById('xmlPreview');
      Prism.highlightElement(block);
    }

    function generateMermaid(nodesList) {
      const lines = ['flowchart TD'];
      nodesList.forEach((n) => {
        const label = n.label || n.type;
      if (n.type === 'Start') lines.push(`  ${n.id}([START: ${label}])`);
      else if (n.type === 'End') lines.push(`  ${n.id}([END: ${label}])`);
      else if (n.type === 'Decision') lines.push(`  ${n.id}{DECISION: ${label}\\n api: ${n.apiName || n.id}}`);
      else if (n.type === 'Assignment') lines.push(`  ${n.id}[ASSIGNMENT: ${label}\\n api: ${n.apiName || n.id}\\n set: ${n.assignments || ''}]`);
      else if (n.type === 'Screen') lines.push(`  ${n.id}[SCREEN: ${label}\\n api: ${n.apiName || n.id}]`);
      else if (n.type === 'GetRecords') lines.push(`  ${n.id}[GET: ${label}\\n api: ${n.apiName || n.id}\\n object: ${n.object || ''}\\n field: ${(n.fields || '').split(',')[0] || ''}]`);
      else if (n.type === 'Loop') lines.push(`  ${n.id}[LOOP: ${label}\\n api: ${n.apiName || n.id}\\n condition: ${n.loopCondition || 'auto'}\\n iterations: ${n.iterationCount || 'auto'}]`);
      else if (n.type === 'Wait') lines.push(`  ${n.id}[WAIT: ${label}\\n api: ${n.apiName || n.id}\\n waitFor: ${n.waitFor || 'signal'}\\n duration: ${n.waitDuration || 'auto'}]`);
      else if (n.type === 'Fault') lines.push(`  ${n.id}[FAULT: ${label}\\n api: ${n.apiName || n.id}\\n source: ${n.faultSource || 'error'}\\n message: ${n.faultMessage || 'recover'}]`);
      else lines.push(`  ${n.id}[${label}]`);
      });
      nodesList.forEach((n, idx) => {
        if (n.type === 'Decision') {
          if (n.yesNext) lines.push(`  ${n.id} -->|Yes| ${n.yesNext}`);
          if (n.noNext) lines.push(`  ${n.id} -->|No default| ${n.noNext}`);
        } else if (n.next) {
          lines.push(`  ${n.id} --> ${n.next}`);
        } else if (!n.next && idx < nodesList.length - 1 && n.type !== 'End') {
          lines.push(`  ${n.id} --> ${nodesList[idx + 1].id}`);
        }
      });
      const merged = lines.join('\n');
      latestMermaid = merged;
      return merged;
    }

    function generateDsl(nodesList) {
      const start = nodesList.find((n) => n.type === 'Start')?.id || nodesList[0]?.id || '';
      const elements = nodesList.map((n) => {
        const base = {
          id: n.id,
          type: n.type,
          apiName: n.apiName || n.id,
          label: n.label,
        };
      if (n.type === 'Decision') {
        const outcomes = [];
        if (n.yesNext) outcomes.push({ name: 'Yes', next: n.yesNext });
        if (n.noNext) outcomes.push({ name: 'No', next: n.noNext, isDefault: true });
        return { ...base, outcomes };
      }
      if (n.type === 'Assignment') {
        return { ...base, assignments: n.assignments ? [{ variable: 'v_Flag', value: n.assignments }] : [], next: n.next };
      }
      if (n.type === 'GetRecords') {
          const fields = (n.fields || '')
            .split(',')
            .map((f) => f.trim())
            .filter(Boolean);
          const filters = (n.filters || '')
            .split(';')
            .map((p) => p.trim())
            .filter(Boolean)
            .map((pair) => {
              const [field, value] = pair.split('=')
                .map((s) => s.trim());
              return { field, operator: 'EqualTo', value };
            });
        return { ...base, object: n.object || '', fields, filters, next: n.next };
      }
      if (n.type === 'Loop') {
        return {
          ...base,
          next: n.next,
          condition: n.loopCondition || '',
          iterations: n.iterationCount || '',
        };
      }
      if (n.type === 'Wait') {
        return {
          ...base,
          next: n.next,
          waitFor: n.waitFor || '',
          duration: n.waitDuration || '',
        };
      }
      if (n.type === 'Fault') {
        return {
          ...base,
          next: n.next,
          source: n.faultSource || '',
          message: n.faultMessage || '',
        };
      }
      if (n.type !== 'End') {
        return { ...base, next: n.next };
      }
        return base;
      });
      const payload = {
        version: 1,
        flowApiName: 'VisualizerFlow',
        label: 'Visualizer Flow',
        processType: 'Autolaunched',
        startElement: start,
        elements,
      };
      latestDslData = payload;
      return payload;
    }

    document.querySelectorAll('[data-add]').forEach((btn) => {
      btn.addEventListener('click', () => {
        const type = btn.dataset.add;
        const base = typeDefaults[type] ? typeDefaults[type]() : { type, label: type };
        const id = `${type}_${nodes.filter((n) => n.type === type).length + 1}`;
        nodes.push({ id, apiName: id, x: 100 + nodes.length * 60, y: 100 + (nodes.length % 3) * 80, ...base });
        selectedId = id;
        renderAll();
        markCurrentFlowDirty();
      });
    });
    importDropzone?.addEventListener('click', () => importFileInput?.click());
    importDropzone?.addEventListener('dragover', (event) => {
      event.preventDefault();
      importDropzone.classList.add('hover');
    });
    importDropzone?.addEventListener('dragleave', () => importDropzone.classList.remove('hover'));
    importDropzone?.addEventListener('drop', (event) => {
      event.preventDefault();
      importDropzone.classList.remove('hover');
      const file = event.dataTransfer?.files?.[0];
      if (file) {
        handleImportFile(file);
      }
    });
    importFileInput?.addEventListener('change', (event) => {
      const file = event.target?.files?.[0];
      if (file) {
        handleImportFile(file);
      }
      importFileInput.value = '';
    });
    loadMermaidFromText?.addEventListener('click', async () => {
      const text = importTextarea.value.trim();
      if (!text) {
        updateImportStatus('Enter Mermaid text before loading.', 'warning');
        return;
      }
      await importMermaidText(text);
    });
    loadDslFromText?.addEventListener('click', async () => {
      const text = importTextarea.value.trim();
      if (!text) {
        updateImportStatus('Paste DSL JSON before loading.', 'warning');
        return;
      }
      await importDslText(text);
    });
    loadXmlFromText?.addEventListener('click', async () => {
      const text = importTextarea.value.trim();
      if (!text) {
        updateImportStatus('Paste Flow XML before loading.', 'warning');
        return;
      }
      await importXmlText(text);
    });
    openImportExportBtn?.addEventListener('click', () => openImportExport());
    closeImportExportBtn?.addEventListener('click', () => closeImportExport());
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        if (importExportModal && !importExportModal.classList.contains('hidden')) {
          closeImportExport();
          event.preventDefault();
          return;
        }
        if (historyModal && !historyModal.classList.contains('hidden')) {
          closeHistoryModal();
          event.preventDefault();
          return;
        }
        if (shortcutsModal && !shortcutsModal.classList.contains('hidden')) {
          closeShortcutsPanel();
          event.preventDefault();
          return;
        }
      }
      handleGlobalShortcuts(event);
    });

    captureHistoryBtn?.addEventListener('click', () => {
      saveSnapshot('Manual snapshot');
      showBanner({ type: 'success', title: 'Snapshot saved', message: 'Flow snapshot stored in browser history.' });
    });
    openHistoryBtn?.addEventListener('click', openHistoryModal);
    historyCloseBtn?.addEventListener('click', closeHistoryModal);
    historyList?.addEventListener('click', (event) => {
      const button = event.target instanceof Element ? event.target.closest('button') : null;
      if (!button) return;
      const flow = getActiveFlow();
      const index = Number(button.dataset.index);
      const entry = flow?.history?.[index];
      if (!entry) return;
      if (button.dataset.action === 'restore') {
        restoreSnapshot(entry);
      }
      if (button.dataset.action === 'compare') {
        compareSnapshot(entry);
      }
    });
    toggleShortcutsBtn?.addEventListener('click', () => {
      const nextState = !shortcutsEnabled;
      setShortcutsState(nextState);
      showBanner({
        type: 'info',
        title: 'Shortcuts',
        message: nextState ? 'Keyboard shortcuts enabled.' : 'Keyboard shortcuts paused.',
        duration: 4000,
      });
    });
    showShortcutsGuideBtn?.addEventListener('click', openShortcutsPanel);
    closeShortcutsPanelBtn?.addEventListener('click', closeShortcutsPanel);

    downloadMermaidHub?.addEventListener('click', () => {
      const data = generateMermaid(nodes);
      downloadBlob(`${activeFlowId || 'flow'}.mmd`, data, 'text/plain');
    });
    downloadDslHub?.addEventListener('click', () => {
      const dsl = generateDsl(nodes);
      downloadBlob(`${activeFlowId || 'flow'}.dsl.json`, JSON.stringify(dsl, null, 2), 'application/json');
    });
    downloadXmlHub?.addEventListener('click', () => {
      if (!latestXml) {
        showBanner({ type: 'warning', title: 'No XML', message: 'Compile the flow before downloading XML.' });
        return;
      }
      downloadBlob(`${activeFlowId || 'flow'}.flow-meta.xml`, latestXml, 'application/xml');
    });
    downloadSvgHub?.addEventListener('click', () => {
      const svg = generateSvgSnapshot();
      if (!svg) {
        showBanner({ type: 'warning', title: 'No nodes', message: 'Add nodes before exporting SVG.' });
        return;
      }
      downloadBlob(`${activeFlowId || 'flow'}.svg`, svg, 'image/svg+xml');
    });
    downloadPngHub?.addEventListener('click', async () => {
      const png = await generatePngSnapshot();
      if (!png) {
        showBanner({ type: 'warning', title: 'No nodes', message: 'Add nodes before exporting PNG.' });
        return;
      }
      downloadFromDataUrl(png, `${activeFlowId || 'flow'}.png`);
    });

    function handleImportFile(file) {
      if (!file) return;
      updateImportStatus(`Reading ${file.name}...`);
      const reader = new FileReader();
      reader.onload = () => {
        const text = reader.result?.toString?.() || '';
        const ext = (file.name.split('.').pop() || '').toLowerCase();
        if (ext === 'mmd') {
          importMermaidText(text);
        } else if (ext === 'json' || ext === 'dsl') {
          importDslText(text);
        } else if (ext === 'xml' || file.name.toLowerCase().includes('.flow-meta')) {
          importXmlText(text);
        } else {
          updateImportStatus('Unsupported file type. Use .mmd, .json/.dsl, or .xml', 'warning');
        }
      };
      reader.onerror = () => updateImportStatus('Failed to read the file.', 'error');
      reader.readAsText(file);
    }

    function openImportExport() {
      if (!importExportModal) return;
      importExportModal.classList.remove('hidden');
      importExportModal.setAttribute('aria-hidden', 'false');
      updateImportStatus('Drop a file or paste text to import.', 'info');
      importTextarea.value = '';
    }

    function closeImportExport() {
      if (!importExportModal) return;
      importExportModal.classList.add('hidden');
      importExportModal.setAttribute('aria-hidden', 'true');
    }

    function downloadFromDataUrl(url, filename) {
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }
    advancedButtons.forEach((btn) => {
      btn.addEventListener('click', () => highlightAdvancedNodes(btn.dataset.advancedTarget));
    });
    emptyStartTutorialBtn?.addEventListener('click', () => openTutorial(0));
    emptyLoadTemplateBtn?.addEventListener('click', () => loadTemplate('onboarding'));
    tutorialTrigger?.addEventListener('click', () => openTutorial(0));
    tutorialPrev?.addEventListener('click', () => navigateTutorial(-1));
    tutorialNext?.addEventListener('click', () => {
      if (tutorialStep === tutorialSteps.length - 1) {
        closeTutorial();
      } else {
        navigateTutorial(1);
      }
    });
    tutorialSkip?.addEventListener('click', closeTutorial);
    window.addEventListener(
      'scroll',
      () => {
        if (tutorialActive) {
          highlightTutorialTarget(tutorialSteps[tutorialStep]?.selector);
        }
      },
      true,
    );
    window.addEventListener('resize', () => {
      if (tutorialActive) {
        highlightTutorialTarget(tutorialSteps[tutorialStep]?.selector);
      }
    });

    document.getElementById('exportMermaid').addEventListener('click', () => {
      const mermaid = generateMermaid(nodes);
      navigator.clipboard?.writeText(mermaid).catch(() => {});
      output.textContent = 'Mermaid generated (copied to clipboard if permitted).';
      mermaidPreview.textContent = mermaid;
    });

    document.getElementById('exportDsl').addEventListener('click', () => {
      const dsl = generateDsl(nodes);
      const text = JSON.stringify(dsl, null, 2);
      navigator.clipboard?.writeText(text).catch(() => {});
      output.textContent = 'DSL JSON generated (copied to clipboard if permitted).';
    });

    document.getElementById('zoomIn').addEventListener('click', () => setScale(scale + 0.15));
    document.getElementById('zoomOut').addEventListener('click', () => setScale(scale - 0.15));
    document.getElementById('resetView').addEventListener('click', () => {
      scale = 1;
      panX = 0;
      panY = 0;
      applyTransform();
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      setScale(scale + delta);
    });

    canvas.addEventListener('mousedown', (e) => {
      if (e.target.closest('.node')) return;
      isPanning = true;
      panStart = { x: e.clientX, y: e.clientY };
      canvas.style.cursor = 'grabbing';
    });

    window.addEventListener('mousemove', (e) => {
      if (!isPanning) return;
      const dx = e.clientX - panStart.x;
      const dy = e.clientY - panStart.y;
      panStart = { x: e.clientX, y: e.clientY };
      panX += dx;
      panY += dy;
      applyTransform();
    });

    window.addEventListener('mouseup', () => {
      isPanning = false;
      canvas.style.cursor = 'grab';
    });

    compileButton.addEventListener('click', async () => {
      if (nodes.length === 0) {
        xmlPreview.textContent = 'Add nodes before compiling.';
        output.textContent = 'Cannot compile empty canvas.';
        setXmlStatus('Canvas is empty. Add Start/Screen nodes before compiling.', 'warning');
        showBanner({
          type: 'warning',
          title: 'Canvas empty',
          message: 'Add nodes from the toolbox or use a template before compiling.',
        });
        setIssueState('warning', ['Add nodes before compiling.']);
        setLoadingState(false);
        highlightXmlBlock();
        return;
      }
      const mermaid = generateMermaid(nodes);
      mermaidPreview.textContent = mermaid;
      output.textContent = 'Compiling via backend...';
      setXmlStatus('Sending diagram to backend compiler...', 'info');
      setLoadingState(true, 'Compiling flow...');
      setIssueState('info', ['Sending diagram to backend compiler...']);
      setButtonLoading(compileButton, true, 'Compiling...');
      try {
        const res = await fetch(`${API_BASE}/api/compile`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ mermaidText: mermaid }),
        });
        const data = await safeJson(res);
        if (!res.ok) {
          const apiMessage = data?.message || data?.error || `Compile failed with status ${res.status}`;
          throw new Error(apiMessage);
        }
        if (Array.isArray(data.errors) && data.errors.length > 0) {
          xmlPreview.textContent =
            'Errors:\n' + data.errors.map((e) => `- ${(e.code || 'ERR').toUpperCase()}: ${e.message}`).join('\n');
          output.textContent = 'Validation errors; XML not generated.';
          setXmlStatus('Validation errors detected. Review the list below.', 'error');
          showBanner({
            type: 'error',
            title: 'Validation failed',
            message: `${data.errors.length} issue(s) detected. ${data.errors[0]?.message || ''}`.trim(),
            sticky: true,
          });
          highlightXmlBlock();
          return;
        }
        xmlPreview.textContent = data.xml || 'No XML generated.';
        xmlPreview.dataset.xml = data.xml || '';
        latestXml = data.xml || '';
        highlightXmlBlock();
        const warnings = Array.isArray(data.warnings) ? data.warnings.filter(Boolean) : [];
        if (warnings.length > 0) {
          showBanner({
            type: 'warning',
            title: 'Compile warnings',
            message: warnings[0],
            duration: 9000,
          });
          setIssueState('warning', warnings);
        } else {
          showBanner({
            type: 'success',
            title: 'XML ready',
            message: 'Flow compiled successfully.',
          });
          setIssueState('success', ['Flow compiled successfully.']);
        }
        output.textContent = 'XML compiled via backend.';
        setXmlStatus('Latest compile succeeded.', 'success');
        setPreviewHint('Compilation succeeded; advanced nodes sync with backend metadata.', 'success');
        saveSnapshot('Compiled snapshot');
      } catch (err) {
        xmlPreview.textContent = 'Error: ' + err.message;
        highlightXmlBlock();
        output.textContent = 'Backend error: ' + err.message;
        setXmlStatus(`Compile failed: ${err.message}`, 'error');
        showBanner({
          type: 'error',
          title: 'Compile failed',
          message: err.message,
          sticky: true,
        });
        setIssueState('error', [err.message]);
      } finally {
        setButtonLoading(compileButton, false);
        setLoadingState(false);
      }
    });

    downloadButton.addEventListener('click', () => {
      const xml = xmlPreview.dataset.xml;
      if (!xml) {
        output.textContent = 'No XML to download. Compile first.';
        return;
      }
      setButtonLoading(downloadButton, true, 'Preparing...');
      const blob = new Blob([xml], { type: 'application/xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'flow.flow-meta.xml';
      a.click();
      URL.revokeObjectURL(url);
      output.textContent = 'XML downloaded.';
      setPreviewHint('Downloaded XML matches the previewed flow.', 'success');
      showBanner({
        type: 'success',
        title: 'Download complete',
        message: 'Flow XML saved locally.',
      });
      setTimeout(() => setButtonLoading(downloadButton, false), 400);
    });

    pingButton.addEventListener('click', async () => {
      output.textContent = 'Pinging backend...';
      setButtonLoading(pingButton, true, 'Checking...');
      showBanner({ type: 'info', title: 'Checking backend', message: 'Calling /health endpoint...' });
      try {
        const res = await fetch(`${API_BASE}/health`);
        const data = await safeJson(res);
        if (!res.ok) {
          throw new Error(data?.message || `Health endpoint returned ${res.status}`);
        }
        output.textContent = JSON.stringify(data, null, 2);
        showBanner({
          type: 'success',
          title: 'Backend reachable',
          message: `Health: ${data.status || 'ok'}`,
          duration: 5000,
        });
      } catch (err) {
        output.textContent = 'Error: ' + err.message;
        showBanner({
          type: 'error',
          title: 'Backend unreachable',
          message: err.message,
          sticky: true,
        });
      } finally {
        setButtonLoading(pingButton, false);
      }
    });

    document.getElementById('reset').addEventListener('click', () => {
      replaceActiveFlowNodes([...sampleNodes]);
      selectedId = null;
      renderAll();
      markCurrentFlowDirty();
      output.textContent = 'Ready.';
      clearIssueState();
      setPreviewHint('Canvas reset. Start building or load a template.', 'info');
      showBanner({
        type: 'info',
        title: 'Builder reset',
        message: 'Sample flow restored; modify it or add new nodes.',
        duration: 2500,
      });
    });

    document.getElementById('themeToggle').addEventListener('click', toggleTheme);

    function toggleTheme() {
      const current = document.body.getAttribute('data-theme') || 'dark';
      const next = current === 'dark' ? 'light' : 'dark';
      document.body.setAttribute('data-theme', next);
      document.getElementById('themeToggle').setAttribute('aria-pressed', next === 'dark' ? 'false' : 'true');
      localStorage.setItem('theme', next);
      showBanner({
        type: 'info',
        title: 'Theme switched',
        message: `${next.charAt(0).toUpperCase() + next.slice(1)} mode is now active.`,
        duration: 2500,
      });
    }

    function restoreTheme() {
      const stored = localStorage.getItem('theme');
      if (stored) {
        document.body.setAttribute('data-theme', stored);
        document.getElementById('themeToggle').setAttribute('aria-pressed', stored === 'dark' ? 'false' : 'true');
      } else {
        document.body.setAttribute('data-theme', 'dark');
      }
    }

    init();
  </script>
</body>
</html>
